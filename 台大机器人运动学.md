# **台大机器人学之运动学**



## **一、导论：**

**注：本章的角度转动逆时针为正方向；**

### **1、一个刚体的状态该如何描述：**

​		**平面：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902151923057.png)

​					移动 * 2 + 转动 * 1；

​		**空间：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902152053771.png)

​					移动 * 3 + 转动 *3；



### **2、该如何整合表达刚体的状态：**

​		在刚体上建立**frame**，常建立在质心上；（在实际机器人上，我们一般会建立在一个定点上，即关节）

- 移动：由body frame的**原点位置**判定；
- 转动：由body frame的**姿态**判断；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902152626807.png)

​	

### **3、一个刚体的运动状态该如何描述：**

​		利用各个DOF的微分，将位移和姿态转换到速度和加速度等运动状态；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902154446472.png)









## **二、移动：**

**移动**：以向量P来描述{B}的原点相对于{W}的状态；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902155233233.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902155315706.png)

向量也是表示一个方向，而坐标轴也是一个方向，所以，刚体的姿态是由刚体的body frame来表示，也可以使用一个向量来表示；**所以向量有两个作用：确定刚体的绝对位置、确定刚体的姿态**；









## **三、转动：**

转动：描述{B}相对于{A}之姿态；

​	![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902160531128.png)

第一步，将{B}的主轴形成的向量（column vector）排在一起（称为旋转矩阵）（{B}相对于{A}的姿态），如下：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902162824418.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902163423748.png)

我们可将{B}的**basis**看成在{A}中的一个向量，投影在{A}的每一个**basis**上；

实例：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902164103458.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902164553565.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902164602351.png)









## **四、旋转矩阵：**

### **1、功能一：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902170119345.png)

### **2、特性一：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902170136655.png)



### **3、特性二：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902171131050.png)

得到为单位矩阵（主对角线值为1，其他位置数值为0）；

我们学过线性代数可以知道，**一个矩阵乘以它的逆矩阵得到一个单位矩阵**；

可得出：**一个旋转矩阵的逆矩阵 等于 其转置矩阵**；



### **4、特性三、**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902192126589.png)

该图片给出了**正交矩阵**的定义（即我们这里使用的旋转矩阵）：

​		正交矩阵的“转置”等于“逆矩阵”；

列向量：**标准正交基**（Orthonormal Basis）

- “Length = 1”：列向量的模长为 1（单位向量）。
- “Mutually perpendicular”：任意两列向量的点积为 0（相互垂直）。
- 物理意义：正交矩阵的列向量可以看作 “新坐标系的坐标轴方向”—— 比如，用正交矩阵描述机器人末端坐标系相对于基坐标系的旋转时，矩阵的列就是末端坐标系\(x,y,z\)轴在基坐标系下的方向向量。
- 正交矩阵的每一列都是“单位向量”且相互垂直；

**旋转矩阵的自由度（DOFS）：**

​		旋转矩阵 R 是正交矩阵的一种（行列式为 1，对应 “纯旋转”；若行列式为 - 1，则包含反射（镜像））。

​		旋转矩阵 R 是 3 * 3 矩阵，因此有 3 * 3 = 9 个元素。但这些元素并非完全独立，因为旋转矩阵需满足 **“列向量是标准正交基”** 的约束：

（1）“模长为 1” 的约束（3 个约束），旋转矩阵的**每一列向量**都必须是**单位向量**（模长为 1）：

- 列向量有 3 列（对应新坐标系的 \(x、y、z\) 轴方向）；
- 每列需满足 “模长为 1” 的条件（如第 1 列 [r11, r21, r31]^T 需满足 \(r11^2 + r21^2 + r31^2 = 1）；
- 3 列共产生 3 个约束。

（2）“相互垂直” 的约束（3 个约束），旋转矩阵的**任意两列向量**必须**相互垂直**（点积为 0）：

- 两列组合有 3 种：第 1 列与第 2 列、第 1 列与第 3 列、第 2 列与第 3 列；
- 每对列需满足 “点积为 0” 的条件（如第 1 列与第 2 列需满足 \(r11r12 + r21r22 + r31r32 = 0）；
- 3 对组合共产生 3 个约束。

**自由度的推导：独立参数的数量**

自由度的定义是 “完全描述系统所需的独立参数数量”。

- 旋转矩阵有 9 个元素，但受 \(3 + 3 = 6\) 个约束；
- 因此，独立元素的数量为 \(9 - 6 = 3\)，即**旋转矩阵的自由度为 3**。

所以该旋转矩阵刚好与刚体旋转有3个自由度对应；



### **5、功能二：**

​		前面我们讲了旋转矩阵的第一个功能，即除描述{B}相对于{A}之姿态，也可用于转换向量之坐标；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902210113247.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250902210104523.png)

**原向量在新frame下的坐标为原frame在新frame下的旋转矩阵乘以向量在原frame下的坐标；**



### **6、功能三、**

​		可进一步的描述物体转动的状态；（注：此处仅针对单一主轴转动）

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903001840709.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903002233515.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903003354769.png)

此处解题原理可看上处功能二；









## **五、旋转矩阵与转角：**

### **1、问题一：**		

​		空间中的**Rotation**是3 DOFS，那要如何把一般**matrix**所表达的姿态，拆解成3次旋转角度，以对应到3个DOFS；（如何把旋转矩阵三个自由参数与实际旋转角度对应）

**拆解成三次旋转连乘的注意事项：**

- Rotation不是commutable，所以多次旋转的先后顺序需要明确定义；
- 旋转转轴也需要明确定义。是对（固定不动）的转轴旋转？或是对“转动的frame当下所在”的转轴旋转？

**两种拆解方式：**

- 对方向（固定不动）的转轴旋转：Fixed angles（world frame）
- 对“转动的frame当下所在”的转轴方向旋转：Euler angles（body frame）





### **2、方法一：（Fixed angles）**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903134512239.png)

![2b79e287dd3ac54a50d04bc56c7aaad9](C:\Users\21716\Pictures\Screenshots\2b79e287dd3ac54a50d04bc56c7aaad9.gif)

针对蓝色的frame的转轴对红色的frame进行旋转；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903143322749.png)

附：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903144138628.png)

​		向量与旋转矩阵相乘后得到是在新frame下的坐标（依旧是一个向量），所以此处先转的放后面

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903153428865.png)

存疑的可以自行推导一下，可以得到上式；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903154734472.png)

 

上面我们讲了已知转的顺序以及三个角度得到旋转后的Rotation matrix，现在我们来讲讲由Rotation matrix推算angles；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903162545740.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903162755904.png)





### **3、方法二、（Euler angles）：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903165356861.png)

![746ab8d1ad397b24a188152a8373ec05](C:\Users\21716\Pictures\Screenshots\746ab8d1ad397b24a188152a8373ec05.gif)

此处旋转顺序为ZYX，后面会讲到是为什么；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903171650593.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903172116988.png)

这里从计算上阐明了“欧拉角和姿态是一一对应的”

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903172644475.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903172903999.png)



上面我们讲了ZYX的转动顺序，接下来我们来讲讲ZYZ的转动顺序：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903184317018.png)

![3c2ce387faa5ccab5975fd9481a209a6](C:\Users\21716\Downloads\3c2ce387faa5ccab5975fd9481a209a6.gif)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903184740139.png)



现在我们来讲知道Rotation matrix来推angles；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903184941789.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903185334609.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903185903485.png)









## **六、mapping：**

### **1、引入：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903190059279.png)

在前面我们讲了刚体在空间中的移动与转动的表达，但我们无法将转动与移动汇整后进行量化运算，下面我们来讲讲把移动和转动汇整并进行量化运算；





### **2、将转动和移动整合在一起描述：**

​		**Homogeneous transformation matrix**（齐次变换矩阵）

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903190614975.png)

左上角为旋转矩阵，右上角为{B}frame的原点在{A}frame上的投影的向量，下面补上 0 0 0 1；

**注：在齐次变换中，变换顺序是“从右到左”依次执行，即右侧矩阵先作用，左侧矩阵后作用；**



### **3、以mapping，转换向量（或点）之坐标系的方式来确认上式运算的正确性：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903192911264.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903193720884.png)



![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903194105566.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903194113727.png)



![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903194427293.png)



![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903194756303.png)









## **七、Operators：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903233857202.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903235347006.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250903235525175.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250904000632651.png)

根据上面我们已知：如果先移动再旋转得到的结果为：
$$
^AP_2 = R_k(θ)\cdot(^AP_1+^AQ)
$$
所以该题答案为：C（由前面的内容我们可知，先作用的放后面，后作用的放前面）



![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250904110928660.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250904111525842.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250904111652858.png)









## **八、Trans Matrix：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041514893.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041516652.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041528637.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041533929.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041552229.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041553888.png)









## **九、顺向运动学：**

### **1、引言1：**

​		运动学：讨论运动状态本身，未连结到产生运动的力；

- **位置（x）、速度（v）、加速度（a）、和时间（t）之间的关系：**

$$
v = dx/dt 		\\
a = dv/dt 		\\
a = d^2x/dt^2	\\
vdv = adx
$$

- **移动 / 转动：**
  - 位置/姿态
  - 速度/角速度
  - 加速度/角加速度

- **动力学：**

​		讨论力/力矩如何产生运动







### **2、引言2：**

- **机械手臂：**

  - 多个杆件(Link)相串联，具有复杂的几何外形；
  - 杆件间可相对移动或转动，由制动器(电机等)驱动来完成；

- **对应关系：**

  - 需求：手臂末端点状态（位置、速度...）

  - 达成方式：驱动各执行器		
    $$
    ^WP = f(θ_1+θ_2,...,θ_n)
    $$
    

- **描述手臂描述状态的方法：**
  - 找出杆件间的相对几何状态；
  - 在各杆件上建立**frame**，以frame状态来代表杆件状态；







### **3、手臂几何描述方式1：**

- **joint：**
  - 每个**revolute**（旋转关节）或**prismatic**（移动关节）的joint具有1DOF；
  - 每个joint对某特定axis（转动即为转动轴，移动即为移动轴）进行**rotation**（转动）或**translation**（移动）；

- **Link：**
  - 连接joints的杆件，为刚体（rigid body）（即中间没有其他的变形）
  - 编号方式
    - Link0：地杆，不动的杆件；
    - Link1：和Link0相连，第一个可动的杆件；
    - Link2：第二个可动的杆件；
    - 依序下去...；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510012128712.png)







### **4、手臂几何描述方式2：**

在实际的场景中，不太可能会出现所有转动轴都平行的情况，这时可看下面：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510012137754.png)

第**i-1**个转轴在第**i - 1**个Link前；

- 对空间中2个任意方向的axes，两axes之间具有一线段和此2个axes都相互垂直（**该线段是唯一的（大部分情况下并不是只有一条线段，而是Link Length是唯一的），长度是固定的**）；

注：当两个转轴可以相交的时候，我们先把两axis移动到相交在一起，然后用一个平面把两个线段罩在一起，然后垂直于这个平面的线段，即找出中间这个公垂线；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510012144862.png)

即便如此我们还是无法知道空间中两坐标系的之间的相对位置关系，即引入下面的角度；

- 每两杆之间：用α和α即可清楚定义

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510012153525.png)

从这个例子可以得出，我们如果只在意每两杆之间的位置关系，各自只需要两个参数即可；

- 但若要多杆串联，则另需要两个参数（di，θi），来描述相邻线段a（i-1）和a（i）之间的相对几何关系

即用来确定**axis i+1**和**axis i-1**的关系；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510030028059.png)

所以总共需要四个参数才是足够的；针对移动和转动的不同，我们发现只有一个参数在变动；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510030036664.png)







### **5、DH表示法：**

##### **5.1、杆件上建立Frame - 1：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510030043554.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510030040447.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510030045041.png)





#### **5.2、杆件上建立Frame - 2：**

- 地杆  Link0：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031147836.png)

在前面我们把Z轴当作旋转轴，这里，地杆为不动的，所以按照上面的方法不好键**frame**；

为了最简化，我们把第1杆的fame当作地杆的frame；当驱动轴还没有动的时候（地杆的frame和第1杆的frame重合）；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031233512.png)

**我们通常选θ = 0的时候的姿态；**

- **最后一杆：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031238905.png)

因为其没有下一个杆件了，我们的x轴不方便确定，这里为了简便，顺着N - 1杆的x轴方向去延申；





#### **5.3、DH表达法：**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031245673.png)

其专业名词分别为：







### **6、Link Trans：**

#### **6.1、Link Transframations - 1：**

假设我们现在有一点P在**frame i**的坐标已知，我们要将其转换到**frame i-1**下：
$$
^{i-1}P = ^{i-1}_iT×^iP
$$
![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031314600.png)

我们先将**frame i-1**以x轴为旋转轴旋转**α i-1**,得到的frame的**旋转轴**（frame i-1的Z轴）可看成**frame i**的旋转轴（frame i的Z轴）平移过来的旋转轴（Z轴）；然后我们以x轴为移动轴，移动**a i-1**的距离后的frame；再然后我们再以Z轴为旋转轴旋转**θ i**；就得到姿态和frame i的一样的frame了，此时我们只需要再移动d i（**注意向上为正，向下为负**）即为frame i的坐标系；于是我们完成了一个frame到另一个frame的推导；

可以看出我们进行了四次操作：
$$
^{i-1}P = ^{i-1}_RT^R_QT^Q_PT^P_iT^iP
$$
**先转动，再移动，再转动，再移动；**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031321531.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031323961.png)

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202510031324718.png)



















