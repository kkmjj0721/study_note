# *** mujoco---XML学习***

## **目录：**

**1、头声明**

**2、mujoco节点**

**3、compiler节点**

**4、option节点**

**5、visual节点**

**6、asset节点**

**7、worldbody节点**

**8、tendon节点**

**9、actuator节点**

**10、default节点**

**11、sensor节点**

**12、keyframe节点**

**13、equality节点** 

**14、body之间的pos关系**







## **一、头声明**

~~~html
<?xml version="1.0" encoding="utf-8"?>
~~~

version：XML的版本号

encoding：编码格式









## **二、mujoco节点**

​	mujoco节点是该文件下的根节点，在该节点内包括着下面会讲到的所有节点

~~~html
<mujoco model=“xxx”>

</mujoco>
~~~

model为该机器人的name，也可以不写；









## **三、compiler节点**

先讲一下该节点具体有什么作用：

​		官方解释：此元素用于设置内置解析器和编译器的选项。解析编译后不再有任何效果。此处的设置是全局的，适用于整个模型。

然后讲一下在该节点下有那些元素，以及它们有什么作用：

### **1、angle：**

​		此元素用于指定，mjcf模型中的角度是以角度（degree）还是弧度（radian）为单位；在使用时，按如下格式使用：

~~~html
<compiler angle="radian"/>		<!-- 弧度 -->
or
<compiler angle="degree"/>		<!-- 角度 -->
~~~





### **2、autolimits：**

​		此元素会影响“受限”，详细解释可看下图：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250802191037158.png)





### **3、balanceinertia：**

​		官方解释：对于三个对角线元素的所有排列，有效的对角惯性矩阵必须满足 A+B>=C。有些很差 设计的模型违反了此约束，这通常会导致编译错误。如果此属性设置为 “true”，则编译器会在上述情况下将所有三个对角线元素静默地设置为其平均值 违反了条件。

​		这个元素我们一般会在URDF转成MJCF的时候使用，等讲完下两个元素，就展示用法；





### **4、discardvisual：**

​		功能：该属性指示编译器丢弃所有纯粹是视觉上的模型元素，这些元素对物理模拟没有影响（有一个情况例外）

​		好处：这样做通常可以使mjmodel（从mujoco中通过URDF保存的MJCF）结构体更小，并且模拟速度更快；





### **5、meshdir：**

​		这个 `meshdir` 属性主要用于指示编译器在何处查找网格（mesh）和高度场（height field）文件；

​		功能：该属性告诉编译器在哪个目录中查找网格和高度场文件；

路径检查顺序：

- **检查 1**：如果文件名包含绝对路径，则直接使用该绝对路径，不再进行其他更改。
- **检查 2**：如果 `meshdir` 属性被设置并且包含绝对路径，那么完整路径就是 `meshdir` 属性指定的字符串加上文件名。
- **检查 3**：完整路径是主 MJCF 模型文件的路径，如果 `meshdir` 属性被指定，则加上 `meshdir` 属性的值，再加上文件名。

用法：

~~~html
 <mujoco>
    <compiler meshdir="../meshes/" balanceinertia="true" discardvisual="false" />
  </mujoco>
~~~

​		在我们从sw中导出URDF文件后，在 <robot name="xxx"> 后面加上这句话，并且将后面所有STL文件的路径修改成 “../meshes/xxx.STL”（扯远了，这里等我们学完MJCF文件格式后再细讲）；





### **6、eulerseq：**

​		用于统一控制模型里所有 `euler` 旋转的 “旋转轴顺序 + 轴的参考系类型”；

​		**作用：**
​				为所有带 “空间坐标系（spatial frames）” 的元素（比如 `body`、`joint` 等）的 `euler` 属性，**指定欧拉旋转的执行顺序 + 旋转轴的参考系类型**。

​		其值为字符串（长度为3），并且只能从`{x, y, z, X, Y, Z}` 里选。第 `n` 位字符，决定 “第 `n` 次旋转绕哪个轴”。

**大小写的区别（核心！）：**

- **小写字母（x/y/z）**：表示旋转轴随 “当前坐标系” 一起转动（ Intrinsic ，内禀旋转 ）。
  比如第一次绕 `x` 转后，坐标系已经转了，第二次绕 `y` 转时，`y` 轴是 “已经被旋转后的坐标系的 y 轴”。
- **大写字母（X/Y/Z）**：表示旋转轴固定在 “父级坐标系”（ Extrinsic ，外禀旋转 ）。
  不管怎么转，`X/Y/Z` 始终参考父级（比如世界坐标系）的轴，不会随当前坐标系转动而变化。

**与 URDF 的兼容：rpy → XYZ：**

​		文档特别提到：URDF 里常用的 `rpy` convention（roll-pitch-yaw 顺序），对应到 Mujoco 的 `eulerseq` 就是 **"XYZ"**（全大写，外禀旋转）。这意味着：如果你从 URDF 转 Mujoco 模型，只要把 `rpy` 逻辑映射到 `eulerseq="XYZ"` ，旋转行为就能对齐。





### **7、总结：**

​		一般我们在MJCF文件中使用的最多的就是**angle**、**autolimits**和**meshdir**；其他的根据自己的需要可去mujoco的官方文档上查找；









## **四、option节点**

​		用于全局整个仿真环境的全局参数和行为规则。它控制着物理引擎的数值计算、碰撞检测、约束处理、可视化等关键行为，对仿真的准确性、性能和行为表现有直接影响。

### **1、核心作用**

`<option>` 节点用于定义仿真的**全局参数**，统一配置物理引擎的底层行为，包括：

- 数值积分方法和精度
- 碰撞检测的规则和优化
- 约束求解的迭代次数和容差
- 可视化和调试相关的设置
- 时间步长和仿真帧率
- 默认单位和坐标系

这些参数会影响整个模型的仿真效果，是构建合理仿真环境的基础。

下面讲解有那些元素；





### **2、timestep：**

​		其是 MuJoCo 仿真中**最重要的参数之一**，直接影响仿真的**精度、稳定性和性能**；

**1）、基本定义：**

- **类型**：实数（real），默认值为 `0.002`（即 2 毫秒）。
- **单位**：秒（seconds）。
- **作用**：定义物理引擎**每一步计算的时间增量**。例如，`timestep="0.002"` 表示每次物理更新对应现实中的 0.002 秒。

**2）、核心影响：**

- **值越小**：仿真越接近真实物理过程，精度和稳定性越高。适合需要高精度的场景（如机器人控制、精密碰撞模拟）。
- **值越大**：计算速度加快，但可能导致数值误差累积，甚至仿真不稳定（如物体穿透、关节抖动）。

- 为了达到**实时仿真**（即仿真速度 ≥ 现实时间），`timestep` 必须大于**每步的 CPU 计算时间**。
- 若使用 `RK4` 积分器（高精度但计算量大），`timestep` 需大于 CPU 时间的 **4 倍**。
- MuJoCo 会通过内部计时器监控 CPU 时间，调整 `timestep` 时需关注此指标。

- MuJoCo 通常能以**超实时速度**仿真机器人系统，但模型复杂度（如大量浮动物体、频繁接触）会显著增加计算负担。
- 在优化或纯计算场景（非实时需求），应尽可能增大 `timestep` 以加快仿真速度。

**3）总结：**

​	基本不用管它，设置为默认的就行（0.002）；





### **3、gravity：**

​		重力加速度矢量；在默认世界方向中，Z轴指向上方；（默认参数 “0 0 -9.81”）（如果想要更精细一点的，可以根据自己所在的地区，在网上查找该地区的重力加速度是多少😎）；





### **4、wind：**

​		介质（即风）的速度矢量；（一般我们都默认为无风状态，或风的影响很小，即“0 0 0”）；





### **5、integrator：**

​		此属性选择要使用的数值积分器。目前可用的积分器有Euler、RK4、implicit、implicitfast；

**选择建议：**

1. **快速验证**：使用 `Euler`，兼顾速度和简单性。
2. **高精度需求**：选择 `RK4`，如机器人控制或科学研究。
3. **复杂约束系统**：使用 `implicit` 或 `implicitfast`，确保稳定性。
4. **实时性能优先**：`Euler` 或 `implicitfast`，根据精度需求权衡。





### **6、magnetic：**	

​		用于定义全局磁场的参数，主要用于模拟磁力计的行为；





### **7、density：**

​		介质的密度；通常我们也是给默认值（如“1.225”，空气的密度）；





### **8、viscosity：**

​		介质的粘度；指定环境介质的粘性系数，影响物体运动时的阻力。（默认值“1.8e-5”，空气阻力）；





### **9、总结：**

​		上面的元素是我们都会用到的，没讲到的可以去官方网站上查找；下面展示代码部分：

~~~html
<option timestep="0.002" gravity="0 0 -9.81" wind="0 0 0" integrator="implicitfast"
        density="1.225"
        viscosity="1.8e-5" />
~~~









## **五、visual：**

​		`<visual>` 节点是控制模型**可视化呈现**的核心配置节点，用于定义仿真环境的视觉效果、渲染参数和交互方式。它不影响物理仿真的动力学计算，仅作用于模型的视觉展示，帮助开发者直观观察仿真过程。

### **1、核心功能**

`<visual>` 节点的主要作用是**配置仿真可视化的各项参数**，包括：

- 渲染质量和细节展示（如关节、碰撞点、力向量等）
- 相机视角和默认姿态
- 光源位置和光照效果
- 可视化标志（控制哪些元素可见）
- 颜色和材质的默认设置

这些配置仅影响仿真的视觉输出，不会改变物理引擎的计算结果。

该根节点下有6个子节点，下面依次给大家讲解一下：





### **2、global子节点：**

​		其是`<visual>` 节点下的一个**杂项子节点**，用于配置无法归类到其他可视化子节点（如 `camera`、`light`、`flags`）的全局视觉参数。它的作用是提供一个 “兜底” 配置区域，方便管理零散的视觉设置。

​		我暂时还没用到，用到了再来补充；😎😎😎

#### **2.1、realtime：**

​		作用是**设置模型在仿真环境（simulate 模式）加载时的 “初始实时因子（real - time factor）”** ，用于控制仿真速度与真实时间的对应关系，它决定了 **仿真运行速度和 “真实物理时间” 的比例关系** ，直白说就是：让你能控制 “仿真里过 1 秒，对应真实世界的时间是多久” ，影响仿真过程的 “时间流逝体感”；

参数规则与效果：

- 设为 `1` ：代表 **“实时仿真”** ，仿真里的 1 秒 ≈ 真实世界的 1 秒 ，仿真速度和现实时间同步；
- 设为 **小于 1**（比如 `0.5` ）：仿真速度比真实时间慢 ，仿真里过 1 秒，真实世界要过 2 秒（因为 `1÷0.5 = 2` ），适合需要 “慢放观察细节” 的场景（比如机器人精密操作、碰撞瞬间分析 ）；
- 规则限制：**必须大于 0** ，不能设 0 或负数，否则仿真逻辑会异常（毕竟时间流逝比例不能无意义或反向

对仿真流程的影响：

- **不改变物理逻辑本质**：无论 `realtime` 怎么设，物理引擎内部的 “物理时间步长（比如每秒计算多少次物理迭代 ）” 是独立配置的（靠 `timestep` 等参数 ）。`realtime` 只影响 **“仿真对外呈现的‘时间流逝速度感’”** ，以及 “仿真运行时，和外部真实时间的匹配关系” ；
- **关联可视化与交互**：在仿真界面里，你看到的 “动画播放速度”“操作指令的响应节奏”，会跟着 `realtime` 变化。比如设 `0.1` ，仿真会像 “慢动作” 播放，方便你截图、录视频分析细节 。





### **3、quality 子节点：**

​		此节点的配置影响渲染质量。值越大，质量越高，但速度可能较慢；

​		下面来讲讲该节点下的元素；

#### **3.1、shadowsize：**

​		用于指定阴影映射（计算机图形学中用于实时渲染的技术）；（通常默认值为“16384”）；



#### **3.2、offsamples：**

​		用于指定离屏渲染时的多重采样数量。多重采样是一种抗锯齿技术，用于减少渲染图像边缘的抗锯齿外观；

**影响：**

​		**抗锯齿效果：**值越大，抗锯齿效果越好，图像边缘越平滑；

​		**性能：**更大的值会增加GPU的计算负担，可能导致渲染速度变慢；

通常我们也是给默认的值（“4”）；



#### **3.3、numslices：**

- 用于指定几何基本体（比如球体、圆柱体等）内部生成的网格的密度。
- 这类网格仅在渲染时使用，而碰撞检测器则是基于底层的解析曲面来工作。
- 该值会作为 “slices” 参数传递给各种可视化函数（就像在 GLU 库中使用的那样）。
- 它指定了围绕 Z 轴的细分数量，类似于经度线的划分，细分数量越多，生成的网格在围绕 Z 轴方向上就越精细。

通常我们给默认值（28）；





### **4、headlight子节点：**

​		这个节点主要用于调整头灯的属性，下面来讲解它的作用：	

**头灯的基本情况：**

- 头灯是一种内置的光源，也就是说，即使模型中没有显式地定义任何其他光源，头灯也会存在。
- 它是一种定向光，以当前相机为中心，并且指向相机所朝向的方向。这意味着头灯的光照方向会随着相机的视角变化而变化，始终照亮相机所看的区域。
- 头灯不会投射阴影，这是因为在这种情况下阴影是不可见的（可能是由于头灯的特性或者场景的设置导致阴影无法正常显示）。

**与其他光源的关系：**

- 光源是叠加的（additive）。如果在模型中显式地定义了其他光源，那么为了避免场景过亮，通常需要降低头灯的强度。因为多个光源同时作用时，它们的光照效果会叠加在一起，如果头灯强度过高，可能会导致场景的亮度不符合预期。

下面再来讲解一下这个子节点中的一些元素的用法：

#### **4.1、diffuse：**

​		此元素用于设置头灯的漫反射光分量。漫反射光分量是指当光线照射到物体表面时，向各个方向均匀反射的光，它的强度与光源的方向和物体表面的法向量有关。

​		其值为real（3）；这是一个包含三个浮点数的向量，对应红、绿、蓝三个颜色通道，这里的值均为0.4，即头灯的漫反射光在红、绿、蓝、三个通道上的强度都是0.4；



#### **4.2、specular：**

​		该元素用于设置头灯的镜面反射光分量。镜面反射光分量是指当光线照射到物体表面时，在特定方向上产生的高光反射，它的强度与光源的方向、物体表面的法向量以及观察者的位置有关。

​			其值为real（3）；这是一个包含三个浮点数的向量，对应红、绿、蓝三个颜色通道，这里的值均为 0.5，即头灯的镜面反射光在红、绿、蓝三个通道上的强度都是 0.5；



#### **4.3、active：**

​		这个元素用于启用或禁用头灯；

​		当值为0时，表示禁用头灯、为1时表示启用头灯；



#### **4.4、ambient：**

​		该元素用于设置头灯（headlight）的环境光分量。在 OpenGL 的概念中，环境光分量是指在场景中所有方向上均匀散射的光，它不依赖于光源的位置和方向。

​		一般不用（用了，再来补充😎）





### **5、rgba子节点：**

​		该节点专门用来配置各类“视觉装饰对象”的颜色和透明度，比如模型里的一些非碰撞、仅作视觉装饰的部件（像机器人外壳上的装饰条纹、场景里的虚拟标记线、纯可视化的辅助几何元素等 ）；

​		下面来讲解一下该节点下的元素的作用：

#### **5.1、fog：**

​		这是 MuJoCo 物理仿真引擎中与  雾化效果（Fog）相关的配置说明，用于在仿真可视化场景里模拟 “雾” 的视觉效果，让场景更贴近真实环境（比如模拟户外远距离视物发灰、发淡的雾化感 ），详细拆解用法：		

​		其参数为一个四维的浮点型参数（0 0 0 1），前三个对应的是RGB通道（值范围 [0,1]，0 是最小强度，1 是最大，类似 `(0,0,0)` 转成归一化的雾色 ）；最后一个是Alpha通道（透明度），值范围[0,1]，`1` 代表雾色完全不透明（如果设 0，雾效果相当于关闭，因为完全透明了 ）。



#### **5.2、haze：**

​		这是 MuJoCo 物理仿真引擎中与 **“地平线雾霭（haze）”** 相关的配置，主要用于 **让 “无限平面（infinite plane，可理解为地面、水面等基础平面）” 和 “天空盒（skybox，模拟天空环境的包裹式纹理 / 颜色）” 之间实现 “平滑过渡”** ，让场景的天空与地面衔接更自然，让场景可视化效果更连贯、逼真。

​		其参数是一个四维的浮点型参数（0 0 0 1），前三个参数对应RGB通道值范围 [0,1]，`1` 代表最大强度，类似 `(255,255,255)` 归一化后的值 ）；最后一个是Alpha通道（透明度），值范围[0,1]，`1` 代表雾霭颜色完全不透明（设 0 的话，雾霭效果相当于关闭，因为完全透明了 ）。





### **6、总结：**

​		在该节点下主要是一些可视化的配置，有时我们并不需要使用上面讲的所有子节点（还有几个不常用的没有列出，需要自行找官网查阅资料），下面给出一份配置代码：

~~~html
<visual>
        <global realtime="1" />
        <quality shadowsize="16384" numslices="28" offsamples="4" />
        <headlight diffuse="1 1 1" specular="0.5 0.5 0.5" active="1" />
        <rgba fog="1 0 0 1" haze="1 1 1 1" />
    </visual>
~~~











## **六、asset节点：**

​		`asset` 节点是一个 **“资产分组定义元素”** ，核心作用是 **集中管理、定义可复用的 “资产”（比如纹理、网格、材质等资源）** ，让模型其他部分能便捷引用这些资产，提升配置效率和可维护性。

​		`asset` 本身 **没有独立属性（does not have attributes）** ，但它是一个 **分组容器** ，用来包裹、组织 MuJoCo 里的各类 “资产定义” 。你可以把它理解成一个 “资源仓库”，里面存着：

- **纹理（texture）**：给模型表面贴的图案（比如机器人外壳的纹理、地面的材质纹理 ）；
- **网格（mesh）**：3D 模型的几何结构文件（比如复杂机械臂的部件网格、场景里的道具模型 ）；
- **材质（material）**：定义物体表面的光学属性（比如金属光泽、塑料质感，影响渲染时的反光、颜色 ）；
- **其他可复用资源**：比如曲线（curve）、字体（font，用于可视化标注 ）等。

通过 `asset` 把这些资源集中放一起，模型里的其他部分（比如 `<body>` 里的实体、 `<geom>` 里的几何元素 ）就可以通过 **“引用名称”** 来复用这些资产，不用重复定义。

下面来讲解一下该节点下的子节点及其用法：

### **1、mesh子节点：**

​		该节点专门用于 **定义 “网格资产”** 的核心元素，作用是创建可复用的 3D 网格资源，供模型中的 `geom`（几何元素）引用，实现复杂形状的可视化与物理模拟。

MuJoCo 主要处理 **三角化网格**（triangulated meshes ），支持加载的文件类型包括：

- **STL（二进制）**：工业常用的 3D 模型格式，适合简单几何；
- **OBJ**：更灵活的 3D 格式，支持纹理坐标、材质等信息；
- **MSH**：MuJoCo 自定义的网格格式（ legacy ，旧版遗留，现在更推荐 OBJ 或 STL ）；
- **XML 内联定义**：直接在 XML 里用 `vertex`（顶点）和 `face`（面）参数写网格数据，不用外部文件。

如果你的网格格式不是三角化的（比如四边形网格），可以用 **MeshLab 等软件转成 STL 或 OBJ**（MuJoCo 会自动处理三角化）。

下面来讲解一下该子节点下的用法：

#### **1.1、name：**

​		你创建的网格资产的名字，如果你是使用vertex建模的网格，则需要给予一个名字，不然后续无法调用，而如果你是从外部引入的文件（如obj、stl），则可加可不加，不加的话，该网格资产的名字为你引入的文件名；



#### **1.2、file：**

​		你所引入文件的文件名，**需加后缀；**



#### **1.3、vertex：**

​		此元素是用来自行构造网格资源的，用于定义3D顶点的位置数据，用来 **存储 3D 顶点的位置信息** ，每个顶点用三维坐标（x、y、z）表示，是构建复杂几何形状（比如网格、点云等 ）的 “基础积木” 。在 MuJoCo 里，网格的面（face）会基于这些顶点坐标来定义形状，进而用于可视化渲染、碰撞检测等。

数据格式：

​		real（3×nvert）表示它是一组，浮点数，长度为3*nvert,其中nvert是顶点个数；每个顶点为（0 0 0），表示x、y、z；

如下:

```html
 <mesh name="tetrahedron" vertex="0 0 0 1 0 0 0 1 0 0 0 1" />

第一个顶点：（0，0，0）
第二个顶点：（1，0，0）
第三个顶点：（0，1，0）
第四个顶点：（0，0，1）
构成一个四面体；
```



#### **1.4、scale：**

​		用于对网格的顶点数据进行坐标轴方向的缩放（及翻转）操作，是调整网格几何尺寸和朝向的重要配置；`scale` 用来 **指定沿 X、Y、Z 三个坐标轴方向，对网格顶点数据的缩放比例** 。通过它可以灵活改变网格在各个轴向的大小，还能利用负数值实现网格沿对应轴的 “翻转” 效果 。当 `scale` 中某个轴的数值为负数时，会 **使网格沿该坐标轴翻转**；





### **2、⁠hfield子节点：**

​		该节点是专门用于 **定义 “高度场（Height Field）资产”** 的核心元素，作用是创建可复用的地形 / 高度场资源，供模型中的 `geom`（类型为 `hfield` ）引用，实现地形模拟（比如地面起伏、复杂地形 ）。在后续中可以在worldbody节点中被使用生成出地形；

可以使用png类型的图片来生成，将 PNG 图片转换为**灰度图**（grayscale ），**像素亮度决定海拔**：

- 白色（亮度高）→ 海拔高；
- 黑色（亮度低）→ 海拔低。

下面来讲讲该节点下的元素：

#### **2.1、name：**

​		你所定义高度场的名字，方便后续gemo调用，也可以不写，默认为文件名；



#### **2.2、file：**

​		调用的png文件的文件名，需加后缀；





### **3 、texture子节点：**

​		该节点是专门用于 **定义 “纹理资产”** 的核心元素，作用是创建可复用的纹理资源，为模型添加表面细节（比如颜色、图案、凹凸 ）。后续被 `material`，然后被gemo调用；

因为纹理类型（比如 2D 纹理、立方体贴图、天空盒 ）不同，需要的参数也不同。`asset/texture` 会根据纹理类型，**动态选择使用哪些属性** 。例如：

- **2D 纹理**：需要 `width`、`height`、`rgb_data` 等参数；
- **立方体贴图（Cube Map ）**：需要 6 张图像（对应立方体的 6 个面 ）；（其定义贴图后直接使用，不需要使用material）
- **天空盒（Skybox ）**：需要全景纹理，通常通过立方体贴图实现。

常用的有两种方式定义纹理：png文件导入、mujoco程序生成；

下面来讲该字节点下的元素：

#### **3.1、name：**

​		你所定义的纹理的名称，无名称时，会自动将名字变为文件名；



#### **3.2、type：**

​		贴图类型，有三种可选（2D，Skybox，Cube），分别为：2D平面映射，天空盒，立方体包裹；不同映射会有不同的辅助参数使用；



#### **3.3、gridsize：**

​		`gridsize` 是 MuJoCo 中用于处理**立方体（cube）或天空盒（skybox）纹理**的一个配置属性，作用是当从**单张图片**加载这类纹理时，定义如何从该图片中提取立方体的 6 个面。

​		当用**1 张图片**作为立方体 / 天空盒纹理的数据源时，`gridsize` 配合 `gridlayout`决定如何从这张图中**切割出 6 个面**（立方体的前 / 后 / 左 / 右 / 上 / 下，或天空盒的 6 个方向）。

- **格式**：`int(2), "1 1"`
  - 两个整数，分别对应**网格的行数（rows）和列数（columns）**。
  - 默认值 `1 1` 表示 “整张图重复贴到立方体所有面”（无需切割）。
- **限制**：
  - 两个整数必须**正整数**（>0）。
  - 行数 × 列数 ≤12（因最多需切割出 6 个面，行列组合需满足能覆盖 6 个面的提取）。
  - 图片的行数 / 列数必须是网格行数 / 列数的**整数倍**，且两个倍数需**相等**（保证切割出的子图是正方形）。

**工作逻辑：**

当用 1 张图作为立方体 / 天空盒纹理时，流程分两种情况：

情况1：gridsize=“1 1”

- 逻辑：**整张图重复贴到立方体所有面**。
- 适用场景：想让立方体 6 个面都显示同一张图（如纯色、简单图案）。

情况 2：`gridsize="m n"`（m>1 或 n>1）

- 逻辑：将图片视为 `m行×n列` 的网格，从网格中**提取 6 个面**（需配合 `gridlayout` 定义提取顺序）。
- 要求：
  - 图片的高度必须是 `m` 的整数倍 → 切割后每行子图高度相等。
  - 图片的宽度必须是 `n` 的整数倍 → 切割后每列子图宽度相等。
  - 最终切割出的子图必须是**正方形**（即：`图片高度/m = 图片宽度/n`）。



#### **3.3、gridlayout：**

​		该节点是 MuJoCo 中配合 **立方体（cube）或天空盒（skybox）纹理** 使用的关键属性，作用是**定义从 “单张复合图” 中提取 6 个面（立方体 / 天空盒的前 / 后 / 左 / 右 / 上 / 下）的规则**。

当用 **1 张图片** 作为立方体 / 天空盒纹理，且 `gridsize` 不是 `1 1`（即需要切割图片）时，`gridlayout` 决定：

- 哪些网格单元（切割出的子图）会被使用；
- 每个被使用的子图对应立方体的哪个面（前 / 后 / 左 / 右 / 上 / 下 ）。

- **格式**：`string, ".........."`（字符串，长度 = `gridsize` 的行数 × 列数 ）。

- 字符集

  ：只能用以下符号，每个符号有特定含义：

  - `.`：表示**未使用**的网格单元（切割出的子图会被忽略 ）。
  - `R`/`L`/`U`/`D`/`F`/`B`：分别对应立方体的 **Right（右）、Left（左）、Up（上）、Down（下）、Front（前）、Back（后）** 面。

- **长度要求**：字符串长度必须等于 `gridsize` 的 `行数×列数`（如 `gridsize="2 3"` → 长度 = 6 ）。

如图：

配置gridsize=“3 4”

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/image-20250821160424928.png)

被分成了3*4=12个子图，将其放在一个二维数组存放，然后用gridlayout里的字符进行分配如：“.L.UFD.R..B.”



#### **3.4、builtin节点：**

​		该元素是mujoco中用于 **生成程序化纹理（Procedural Texture）** 的核心属性，作用是指定 “无需外部文件，由引擎自动生成的纹理类型”。`builtin` 决定是否启用**程序化纹理**（无需加载图片文件，由引擎算法生成 ）。若值不是 `none`，则：

- 纹理被视为 “程序化生成”，忽略 `file` 等文件加载属性；
- 配合 `rgb1`、`rgb2` 等属性，生成渐变、棋盘格、纯色等纹理。

默认为none，使用时需配置；

可选值：与对应纹理：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340209.png)



#### **3.5、rgb1与rgb2：**

​		作为使用mujoco程序生成纹理时才会使用，其值为real（3），三位浮点型数，对应RGB三个通道；



#### **3.6、width：**

​		用于 **定义 “程序化纹理（procedural texture）的宽度”** ，也就是程序化生成的纹理在水平方向（列数）的像素数量；

其值为int（1），一位int类型的数；

​		仅对程序化生成的纹理有用，如果纹理是从外部引入的则会自动忽略；

实际影响

- 质量与性能 trade-off：
  - 数值越大，纹理在水平方向的像素越多，通常能带来 **更高的视觉质量** ，纹理细节更丰富、更清晰，比如复杂的渐变纹理，大宽度值能让颜色过渡更细腻 ；
  - 但同时，更大的宽度意味着更多的像素数据，会 **增加计算和存储开销** ，不过在多数仿真场景中，合理设置（比如几百到几千的宽度 ）对性能影响不大，需要在质量和性能间找平衡 。
- **特殊场景适配**：对于一些本身模式简单的程序化纹理（像 `checker` 棋盘格纹理 ），较小的 `width` 值（比如几十 ）就能呈现出足够好的效果，没必要设置很大的数值，避免资源浪费 。



#### **3.7、height：**

​		用于控制**程序化纹理（Procedural Texture）高度**的属性，仅对 **程序化纹理**（通过 `builtin` 生成的纹理，如渐变、棋盘格 ）生效，定义纹理的**高度（行数）** ，即垂直方向的像素数量。

2. **规则与特殊逻辑**：

- **普通程序化纹理**（非立方体 / 天空盒 ）：
  - `height` 直接决定纹理垂直方向的像素行数，与 `width` 共同控制纹理分辨率。
  - 例：`width="512" height="512"` → 生成 512×512 的程序化纹理。
- **立方体 / 天空盒纹理**：
  - `height` 会被**强制忽略**，自动设置为 `6 × width` 。
  - 原因：立方体 / 天空盒需要 6 个面（前 / 后 / 左 / 右 / 上 / 下 ），引擎会按 `width × width` 为每个面分配空间，总高度需容纳 6 个面（`6×width` ）。
- **文件加载的纹理**：
  - 无论是否为立方体 / 天空盒，`height` 都会被**忽略**（纹理尺寸由文件本身决定 ）。



#### **3.8、mark：**

​		用于 **给程序化纹理（Procedural Texture）添加 “标记效果”** 的属性，作用是在纹理原有颜色基础上，用 `markrgb` 颜色叠加特定图案。（配合markrgb使用）；为程序化纹理（通过 `builtin` 生成的纹理，如渐变、棋盘格 ）添加**额外的标记图案**，用于调试或可视化辅助

**可选值与效果**

`mark` 支持 4 个选项，每个选项对应一种标记方式：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340768.png)



#### **3.9、markrgb：**

​		为上面mark标记的效果进行上色；其值为real（3），三位浮点型数，对应RGB通道；





### **4、material子节点：**

​		 该节点是专门用于 **定义 “材质资产”** 的核心元素，作用是创建可复用的材质资源，为模型元素（如 `geom`、`skin` ）统一管理外观属性（颜色、纹理、反光等 ）。

​		下面来讲讲该节点下的一些元素：

#### **4.1、name：**

​		你所定义材质的名称；方便后续使用（必须要）；



#### **4.2、texture：**

​		用于 **关联材质与纹理资产** ，实现纹理在模型元素上的应用，同时涉及基础渲染与高级渲染（PBR）不同逻辑，核心是 **将 “材质（material）” 与 “纹理资产（texture asset）” 绑定** ，让引用该材质的模型元素（如 `geom` ）自动应用对应的纹理。	

​		其值为字符串，是我们在texture节点中创建的纹理的名字（或文件名）；纹理不能通过material直接加载，必须先通过texture的定义，然后在这里使用；

基础渲染 vs 高级渲染（PBR）：

- **基础渲染**：用 `texture` 关联的纹理，主要用于指定 **RGB 颜色信息**（如漫反射纹理 ）。
- **高级渲染（PBR，基于物理的渲染 ）**：若需更复杂的纹理（如粗糙度、金属度 ），需**省略 `texture` 属性**，改用 `layer` 子元素定义这些纹理类型。



#### **4.3、texrepeat：**

​		用于 **控制 2D 类型纹理（`type="2d"`）重复次数** 的属性，决定纹理图像在模型表面沿不同轴向（通常关联物体尺寸或空间单位 ）重复铺贴的频率，影响纹理呈现的密度效果。

**参数与适用范围**：

- **数据格式**：`real(2), "1 1"` ，包含两个浮点数，分别对应两个方向（一般可理解为 X 轴和 Y 轴方向 ）的重复次数，默认值 `1 1` 表示在两个方向上都只完整显示 1 次纹理图像。
- **适用对象**：仅对 **2D 类型的纹理** 生效，也就是在 `texture` 节点中 `type` 设为 `2d` 的纹理，对于立方体（`cube`）、天空盒（`skybox`）等其他类型纹理，该属性无作用 。



#### **4.4、texuniform：**

​		用于 **控制纹理映射方式** 的属性，影响立方体纹理（cube textures）和 2D 纹理（2d textures）的渲染效果，核心是决定 “纹理如何适配物体尺寸”。

**立方体纹理的逻辑（`type="cube"`）**：

（1）默认值 `false`：直接立方体映射

- 逻辑：纹理直接映射到物体，使用物体的实际尺寸
  - 渲染时，立方体纹理根据物体的真实大小（缩放后的尺寸 ）进行映射。
- **效果**：纹理会 “贴合” 物体的实际形状，适合需要纹理随物体缩放而自然变形的场景。
- **示例**：若物体被放大 2 倍，纹理也会被拉伸 2 倍，保持 “每个面的纹理细节与物体尺寸对应”。

（2）值 `true`：先映射到单位物体，再缩放

- 逻辑：
  1. 渲染器先创建一个**单位物体**（尺寸为 1×1×1 ）；
  2. 将纹理映射到单位物体；
  3. 再将单位物体缩放到实际尺寸。
- **效果**：纹理在缩放后更 “均匀”，避免因物体缩放导致纹理过度拉伸 / 压缩。
- **示例**：若物体被放大 2 倍，纹理会先在单位物体上贴好（1×1 ），再整体放大 2 倍，纹理重复次数不变，视觉上更均匀。

**2D 纹理的逻辑（`type="2d"`）**：

（1）默认值 `false`：按物体表面重复

- 逻辑

  ：2D 纹理的重复次数（由texrepeat定义 ）基于物体的 Z 轴朝向面（z-facing side ）。

  - 纹理重复的参考是 “物体表面的大小”，而非固定空间单位。

- **效果**：物体越大，纹理重复次数越多（因 `texrepeat` 是 “物体表面的重复次数” ）。

- **示例**：`texrepeat="2 2"`，物体表面越大，纹理在 X、Y 方向各重复 2 次，视觉上大物体纹理更密集。

（2）值 `true`：按空间单位重复

- 逻辑

  ：2D 纹理的重复次数（由texrepeat定义 ）基于固定空间单位（如 1 米 ）。

  - 无论物体大小，纹理在 “1 个空间单位” 内重复 `texrepeat` 次。

- **效果**：纹理重复更 “均匀”，与物体尺寸无关，适合需要纹理密度固定的场景。

- **示例**：`texrepeat="2 2"`，无论物体多大，每 1 米空间内纹理重复 2 次，小物体纹理少，大物体纹理多但密度一致。

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340355.png)



#### **4.5、emission：**

​		用于控制 **自发光效果强度** 的属性，作用是让模型表面模拟 “主动发光” 的视觉效果（类似物体自身发光 ）。决定材质的**自发光（Emission）强度** ，让模型表面在渲染时呈现 “主动发光” 的效果，即使没有外部光源也能亮起来。

​		其值为real，“0”；（浮点数，默认为0），取值范围大于等于0，负数会认为是0；

- 效果：
  - `emission=0`：无自发光（默认，依赖外部光源照亮 ）。
  - `emission>0`：材质颜色的 RGB 分量会 “增强发光”，值越大，发光越亮。



#### **4.6、reflectance：**

​		用于 **控制材质反射强度** 的属性，作用是让平面（plane）或盒子（box）类型的 `geom` 模拟 “反射环境” 的视觉效果。决定材质的**反射强度**，让平面或盒子的表面呈现 “反射周围环境” 的效果（类似镜子、金属表面反光 ）。

​		其值为real，“0”；（浮点数，默认为0），取值范围[0,1]（0表示无反射，1表示最大反射）；

- **效果**：值越大，反射越强；值为 0 时无反射。

**适用对象与限制**：

（1）仅对两类 `geom` 生效：

- **平面（plane）**：整个平面都会反射。
- **盒子（box）**：仅**局部 +Z 轴方向的面**（即盒子的 “顶面” ）会反射。

（2）渲染实现的限制：

- MuJoCo 不支持**实时光线追踪**（ray-tracing ），而是用 **模板缓冲区（stencil buffer）+ 投影** 模拟反射。
- 效果简化：模型中**仅第一个反射材质的 `geom`** 会正确渲染反射，**多个反射 `geom` 可能无法正常工作**。





### **5、总结：**

​		附上一份代码（包含了上面的大部分内容）：

~~~html
<asset>
        <mesh name="tetrahedron" vertex="0 0 0 1 0 0 0 1 0 0 0 1" />
        <mesh file="card.obj" scale="1 1 1" />
        <texture type="2d" file="./king_of_clubs.png" />
        <material name="king_of_clubs" texture="king_of_clubs" />
        <hfield name="agent_eval_gym" file="agent_eval_gym.png" size="10 10 1 1" />
        <texture type="skybox" file="../asset/desert.png"
            gridsize="3 4" gridlayout=".U..LFRB.D.." />
        <texture name="plane" type="2d" builtin="checker" rgb1=".1 .1 .1" rgb2=".9 .9 .9"
            width="512" height="512" mark="cross" markrgb=".8 .8 .8" />
        <material name="plane" reflectance="1" texture="plane" texrepeat="1 1" texuniform="true" />
        <material name="box" rgba="0 0.5 0 1" emission="1" />
    </asset>
~~~











## **七、worldbody节点：**

1、构建运动学树：

`worldbody`和`body`元素是用于通过嵌套的方式构建运动学树（kinematic tree）。运动学树描述了模型中各个部件（body）之间的连接关系以及运动传递的方式。`worldbody` 用于定义顶级的物体，而`body`元素则用于定义其他所有非顶级的物体。

2、`worldbody` 的特性：

- **顶级限制**：`worldbody`作为顶级物体，存在一些限制。它不能拥有子元素`inertial`（惯性属性，描述物体的质量、转动惯量等信息）和`joint`（关节，用于定义物体之间的连接和相对运动方式）。这是因为它代表了世界坐标系的原点，是整个模型的基础参考，不需要定义自身的惯性属性或与其他物体的连接关系。
- **无属性**：`worldbody` 不能有任何属性。它主要是作为一个特殊的根节点存在，所有其他物体和关节等元素都基于它来进行定义和构建。
- **自动命名**：`worldbody`对应的物体名称会自动被定义为 “world” ，作为整个模型中所有其他物体的全局参考点。

3、世界坐标系的原点：

`worldbody`对应着世界坐标系的原点，在这个坐标系的基础上，整个运动学树中的其他部分（例如各个物体、关节等）的位置、姿态和运动才得以定义。 比如，其他`body`元素的位置是相对于`worldbody` 来确定的，关节的旋转和移动也是以`worldbody` 所代表的世界坐标系为参考进行计算的。

下面来讲讲该节点下的一些子节点：

### **1、body子节点：**

​		该节点用于构建运动学树，并且可以一层一层的嵌套，来体现各个link和joint之间的关系，再该子节点下所创建的几何体（以后统称geom），加上 `<freejoint />`即可解放（可以交互），而直接在worldbody里面使用geom构建的话，是固定在world中的，无法交互；（一般在该节点我们会使用quat，而不使用euler）（在mujoco中quat的顺序为wxyz）；		

如下代码：

~~~html
<body pos="-1 0 .5">
            <freejoint />
            <geom type="sphere" size="0.1" rgba=".5 0 0 1" />
</body>
~~~

下面来讲一下该节点下的元素及其用法：

#### **1.1、name：**

​		你所创建的body的名字，可给可不给；



#### **1.2、pos：**

​		real（3），（浮点数类型，表示该body在空间下的坐标，x，y，z）；注意当我们嵌套body的时候，内层的body的坐标系是基于上一层body的**“点”**所建的；

​		如果是建立在worldbody下的时候，坐标系为世界坐标系；



### **2、inertial子节点：**		

​		该节点是 **Mujoco 模型中定义刚体惯性属性的核心节点**，作用是给 `body`（刚体）明确 “质量 + 惯性参数”，决定刚体在仿真中的动力学行为（如加速度、旋转惯性等）。

​		惯性参数的 “显式定义 vs 隐式推导”

- **显式定义**：直接在 `inertial` 节点里写质量、惯性张量，精准控制刚体动力学属性。
- **隐式推导**：如果不写 `inertial`，Mujoco 会自动从刚体挂载的 `geom`（几何形状，如盒子、球体）**推算惯性参数**（根据几何尺寸、密度默认值计算）。

但要注意：**模型保存（URDF如转 MJCF 文件）时，不管最初是显式还是隐式，都会用 `inertial` 节点把惯性参数 “显式写出来”** ，方便复用和调试。（该节点仅做介绍，在我们从URDF转MJCF时，程序会自动帮我们生成）

#### **2.1、pos：**

​		控制惯性坐标系下的位置；

**1. 基础定义与强制要求:**

`pos: real(3), required` 表示：

- 类型是**长度为 3 的实数数组**（对应 X/Y/Z 坐标），**必须填写**（required）。
- 作用是**定义 “惯性坐标系（inertial frame）” 在父坐标系（通常是 `body` 的坐标系）中的位置**。

**2. 关键逻辑：与 “惯性参数推导” 的关联:**

核心规则：

只要你在模型里**显式写了 `<inertial>` 节点**（不管有没有填质量、惯性张量），就**必须填 `pos`** ，且会**关闭 Mujoco 自动从 `geom` 推导惯性参数的机制**。



#### **2.2、mass：**

​		该元素用于定义刚体的质量，同时涉及质量相关的物理约束和设计逻辑；

​		基础定义与核心约束

`mass: real, required` 表示：

- 类型是**实数**，**必须填写**（required）（质量是惯性的基础），且**不能为负数**（物理意义上质量不可能为负）。
- 作用是**定义刚体（`body`）的质量**，是动力学仿真中计算加速度（\(F=ma\) ）、惯性行为的核心参数。





### **3、geom子节点：**

​		`geom` 是 **Mujoco 中给 `body`（刚体）附加 “几何形状”** 的核心节点（可在worldbody节点内直接使用，也可在body节点下使用创建可交互的几何体）

**运行时（Runtime）**：

- **外观表现**：决定刚体在仿真可视化中的 “形状、尺寸、颜色”（比如把机器人连杆显示为盒子、球体 ）。
- **碰撞属性**：定义刚体参与物理碰撞的 “几何边界”，用于计算接触力、碰撞检测（比如两个盒子 geom 相撞时的物理响应 ）。

**编译时（Compile Time）**：

- **惯性参数推导**：如果模型中没有显式定义 `<inertial>` 节点，Mujoco 可通过 `geom` 的**形状、密度**，自动推导刚体的**质量、惯性张量**（需配合 `compiler` 节点的 `inertiafromgeom` 等参数 ）。

下面来讲讲该节点下的一些元素及其用法：

#### **3.1、name：**

​		选填，为你所创建的geom命名；



#### **3.2、type与size：**

​		程序化创建geom的类型（type），而size是geom建模需要的参数，根据不同的type，size的长度也不一样；有如下几个可选（**注：在建模过程中，是从我们定义的pos为中心建的**）：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340237.png)

`type` 是 `geom` 节点的**必填属性**，决定：

- **碰撞检测逻辑**：不同形状的碰撞算法不同（如平面无限大、球体是解析曲面 ）；
- **可视化方式**：形状的渲染形态（如平面显示为矩形、球体是三角网格 ）；
- **参数依赖**：每种类型需要的 `size` 等参数含义不同（如平面需要 3 个 `size` 参数，球体只需要 1 个 ）。

**下面来逐一讲解一下每种type与size的搭配：**

**1）、plane：**

​		构建一个平面出来，从世界的中心出发，size的参数为x半长，y半长和渲染时网格线的间距（对运动学仿真无影响，仅优化可视化光影）；该类型一般用于地板的构建，size的取值（如size=“10 10 0.1”，则会生成一个20*20的平面），一般我们给的值为（0 0 0.1）表示在x和y方向上均无限延长的平面；

**2）、hfield：**

​		使用该元素进行建模时，只能建立在worldbody下或静态子节点（避免运动中地形变形），并且使用时，**需提前在asset中创建该材质**；其值为在asset中创建时取的名字；主要作用：**模拟地形**；

​		使用该类型时size会被忽略掉，实际尺寸由`asset/hfield`中的size决定；

**3）、sphere：**

​		该类型是用来建立球形的，并且使用该类型时，size长度为1，为圆的半径；（球心与geom中的pos重合）

**4）、capsule：**

​		该类型是用来建立**“胶囊体”**的，其有两种size的参数形式；

​	**第一种：**

​		size长度为2，第一个参数为胶囊两侧球的半径，第二个参数为圆柱的半长（高度）；

​	**第二种：**

​		size长度为1，但必须使用fromto（这个我们等会再讲）；其中size表示两侧球的半径；

**5）、ellipsoid：**

​		该类型是用来构建椭球体的，其size长度为3，分别表示x半径，y半径，z半径（此处半径也可称为半长轴）；

**6）、cylinder：**

​		该类型是用来构建圆柱体的，其size参数的长度也是有两种：

​	**第一种：**

​		size长度为2，第一个为圆柱两端圆的半径长度，第二个为圆柱的高度半长；

​	**第二种：**

​		size长度为1，第一个为圆柱两端圆的半径长度；

**7）、box：**

​		该模型是用来构建正方体的，size长度为3，表示x半长，y半长、z半长；

**8）、mesh：**

​		该类型主要是用来导入外部模型，当我们选择该类型时，必须在该geom节点添加上mesh=“文件名（或你对引入文件的命名，在asset/mesh中的name）”；



#### **3.3、fromto：**

​		`fromto` 是 Mujoco 中 `geom` 节点的可选属性，**仅对 `capsule`（胶囊体）、`box`（盒子）、`cylinder`（圆柱体）、`ellipsoid`（椭球体）这几种几何形状生效** ，作用是：

​		通过**两个 3D 点的坐标**，替代传统的 `pos`（位置）、`quat`/`euler`（姿态）、`size`（尺寸）中与 “长度方向” 相关的定义，**更直观地指定几何形体的延伸方向、长度，以及几何自身坐标系的位姿**。

​	**参数格式：**

```
fromto: real(6), optional` → 需填入 **6 个实数**，对应两个 3D 点的坐标：
[x1, y1, z1, x2, y2, z2]
```

- `(x1, y1, z1)`：第一个端点的坐标（在父 `body` 的坐标系中 ）。
- `(x2, y2, z2)`：第二个端点的坐标（在父 `body` 的坐标系中 ）。

​	**几何行为规则：**

以这两个点为基础，几何形体的 “延伸方向、自身坐标系、尺寸” 遵循以下逻辑：

- **延伸方向**：几何的 “拉长部分”（如胶囊体的柱身、圆柱体的高度方向 ）连接这两个端点，且几何自身坐标系的 **+Z 轴** 从第一个点指向第二个点（`(x1,y1,z1) → (x2,y2,z2)` ）。
- **垂直方向尺寸**：在垂直于 +Z 轴的方向上，几何的尺寸由 `size` 属性的**第一个值**决定（如胶囊体的半径、盒子的 X/Y 半长 ）。
- **自身坐标系的位置**：几何自身坐标系的原点，位于两个端点的**中点**。
- **自身坐标系的姿态**：通过与 `zaxis` 属性类似的逻辑推导（保证 +Z 轴指向第二个点，再确定 X、Y 轴 ）。

**适用场景与优势：**

**适用场景：**

- 需要**直观描述 “两个点之间的连接体”** 时（如机械臂关节间的连杆、绳索的简化模型 ）。
- 想**避免手动计算几何的位置、姿态**，直接通过端点快速定义延伸方向时。

**优势：**

- **直观性**：用两个端点坐标，比调整 `pos`、`quat`、`size` 更直观，尤其适合复杂连杆结构。
- **关联性**：几何的长度、方向直接与端点绑定，修改端点即可同步调整几何形态，减少参数冗余。



#### **3.4、rgba：**

​		该元素用来设定geom的颜色及透明度的；

参数取值：real（4），四位浮点型数；前三位对应RGB通道，最后一位取值范围为[0,1]，0：透明，1：不透明；



#### **3.5、pos：**

​		我们所创建的geom的在body下的坐标；real（3），3位浮点数，表示XYZ；



#### **3.6、material：**

​		**将预定义的 “材质” 绑定到当前几何形体（`geom`）** ，从而控制 `geom` 的**可视化属性**（如颜色、反光、透明度等 ）；

**材质与颜色的优先级：**

​	**材质的作用范围：**

材质（通过 `<material>` 节点定义）可以设置一系列可视化属性：

- 基础颜色（`rgba`）、环境光反射（`emission`）、漫反射（`diffuse`）、镜面反射（`specular`）、光泽度（`shininess`）等。

这些属性会**应用到绑定的 `geom` 上**，决定其在仿真可视化中的外观。

​	**颜色的 “覆盖规则”：**

如果 `geom` 同时设置了：

- `material`（引用某个材质 ）
- 自身的 `rgba` 属性（直接设置颜色 ）

则：

- **`rgba` 优先**：若 `geom` 的 `rgba` 不是 “内部默认值”（即用户手动改过 ），则 `rgba` 会覆盖材质中的颜色；
- **其他属性保留**：材质中的其他属性（如反光、光泽度 ）依然生效。

**参数：**

​		为我们在**asset/material**中对材质的命名；



#### **3.7、mass：**

​		在`geom`节点下的`mass`为该`geom`的质量，而body下的为该body的质量；如果不给定质量，则会按照水的密度来计算；`mass`和`density`只能存在一个（单位：Kg）；



#### **3.8、shellinertia：**

​		该元素**决定几何形体（`geom`）的惯性计算方式** —— 是按 “实体（体积）惯性” 计算，还是按 “壳（表面）惯性” 计算。

**物理逻辑：实体 vs 壳的惯性：**

 **实体惯性（`shellinertia="false"`，默认）：**

- 假设质量**均匀分布在整个体积中**（体密度，volumetric density ）。
- 惯性计算基于几何的**体积**，符合 “实心物体” 的物理直觉（如实心球、实心盒子 ）。

**壳惯性（`shellinertia="true"`）：**

- 假设质量**全部集中在表面**（面密度，surface density ）。
- 此时，`density` 属性的含义会从 “体密度” 自动切换为 “面密度”（单位面积的质量 ）。
- 惯性计算基于几何的**表面积**，适合模拟 “薄壳结构”（如空心球、金属薄板 ）。

该节点其实我们并不常用，因为其只对mujoco内置的简单几何体有用（我们一般是使用mesh（自定义网格））；



#### **3.9、contype：**

​		该元素是 Mujoco 中 `geom` 节点用于**碰撞过滤（contact filtering）** 的属性，通过 32 位整数位掩码（bitmask）的方式，决定哪些 `geom` 之间会发生碰撞检测、产生接触力，是控制仿真中碰撞逻辑的关键工具。（用于代表geom的碰撞类型）

**工作原理：位掩码与碰撞兼容性：**

​	**位掩码的含义：**

`contype` 和配套的 `conaffinity` 属性，取值都是 32 位整数，可把它们看作由 32 个二进制位组成的 “标签集合”。每个二进制位可理解为一个 “碰撞类别标签”，某一位为 `1` 表示该 `geom` 属于对应的类别 。

​	**碰撞兼容规则：**

两个 `geom`（记为 `geom A` 和 `geom B` ）之间**能产生碰撞接触**的条件是：
`geom A` 的 `contype` 与 `geom B` 的 `conaffinity` 兼容，**或者** `geom B` 的 `contype` 与 `geom A` 的 `conaffinity` 兼容。
“兼容” 的具体判断是：**两个位掩码的二进制位中，存在至少一个相同位置的位都为 `1`** 。

举个简单例子（用 1 位简化说明，实际是 32 位 ）：

- `geom A` 的 `contype = 0b0001`（二进制，第 0 位为 1 ）
- `geom B` 的 `conaffinity = 0b0001`（第 0 位为 1 ）
  → 二者有共同置 `1` 的位（第 0 位 ），会发生碰撞。

再比如：

- `geom C` 的 `contype = 0b0010`（第 1 位为 1 ）
- `geom D` 的 `conaffinity = 0b0001`（第 0 位为 1 ）
  → 没有共同置 `1` 的位，**不会**发生碰撞。

**典型应用场景：**

- **分层控制碰撞**：比如仿真场景中有 “机器人本体”“障碍物”“地面”，可通过给不同类型物体设置不同位掩码，让机器人只与障碍物、地面碰撞，避免机器人自身部件（如关节、连杆 ）之间不必要的碰撞检测（减少计算量、避免物理逻辑错误 ）。
- **动态调整碰撞逻辑**：结合代码，在运行时修改 `contype` 或 `conaffinity` 的位掩码，可动态开启 / 关闭某些碰撞（如模拟 “物体激活 / 冻结碰撞” 的效果 ）。



#### **3.10、conaffinity ：**

​		该元素是 Mujoco 中 `geom` 节点用于 **碰撞过滤（contact filtering）** 的属性，和 `contype` 配合，通过 32 位整数位掩码（bitmask）的方式，决定哪些 `geom` 之间会发生碰撞检测、产生接触力，是控制仿真中碰撞交互逻辑的关键配置。



#### **3.11、group：**

​		该元素是 Mujoco 中 `geom` 节点的属性，主要用于 **对 `geom` 进行分组管理** ，作用体现在编译时的惯性推导、运行时的可视化控制，以及作为自定义计算的标签，是组织和调控仿真元素的实用工具。

​	工作逻辑与功能拆解

**编译时：影响惯性推导（与 `compiler` 协同）：**

在编译模型（从 XML 转换为 `mjModel` 结构 ）时，若需要从 `geom` 推导 `body` 的质量和惯性（通过 `compiler` 节点的 `inertiafromgeom` 开启该功能 ），`group` 会参与筛选 `geom`：

- `compiler` 节点的 `inertiagrouprange` 属性，可指定 “参与惯性推导的 `geom` 分组范围”。只有 `group` 在此范围内的 `geom` ，才会被用于计算 `body` 的质量和惯性 。

示例（简化配置 ）：

```xml
<compiler inertiafromgeom="true" inertiagrouprange="0 5"/> <!-- 仅 group 0~5 的 geom 参与惯性推导 -->
<geom name="geom1" type="box" size="0.1 0.1 0.1" group="2"/> <!-- 会参与推导 -->
<geom name="geom2" type="box" size="0.1 0.1 0.1" group="6"/> <!-- 不参与推导 -->
```

**运行时：控制可视化显隐：**

仿真运行时（Runtime ），`group` 用于可视化工具（如 Mujoco 的内置可视化界面 ）中，**控制整个 `geom` 分组的渲染开关** ：

- 默认规则：`group 0`、`1`、`2` 的 `geom` 可见，其他 `group` 的 `geom` 默认不可见 。
- 实际操作：可在可视化界面中，基于 `group` 批量显示 / 隐藏一类 `geom`（如隐藏所有 `group 3` 的辅助几何 ），方便调试和观察特定部分。

**自定义计算标签：**

`group` 可作为**自定义计算的 “标签”** ，开发者在编写自定义代码（如后处理分析、特殊物理逻辑 ）时，可根据 `group` 对 `geom` 分类处理。比如：

- 给 “传感器挂载点” 的 `geom` 设 `group=10` ，代码中筛选 `group=10` 的 `geom` ，批量读取其位置用于传感器数据模拟





### **4、joint子节点：**

​		是 Mujoco 中用于 **定义关节（Joint）** 的核心节点，作用是在运动学树（Kinematic tree）中，为**当前 `body` 与其父 `body` 之间****创建运动自由度**，决定物体间的相对运动方式（如旋转、平移 ），是构建机械系统运动逻辑的基础。

#### **4.1、工作逻辑与关键规则：**

​	**1）、运动自由度与父 `body` 的关联：**

- 关节定义在某个 `body` 上时，会在**该 `body` 与其父 `body` 之间**引入运动自由度。比如，给机械臂的 “小臂 `body`” 定义关节，会让小臂相对 “大臂 `body`”（父 `body` ）产生可动性。
- 若一个 `body` 定义了**多个关节**，这些关节对应的 “空间变换（`body` 坐标系相对父坐标系的变换 ）” 会**按定义顺序依次叠加** 。

​	**2）、无关节时的默认行为：**

如果某个 `body` 没有定义任何关节，它会被 **“焊接”（welded）到父 `body`** ，即与父 `body` 保持相对固定，无相对运动自由度。

​	**3）、关节的禁用场景：**

关节**不能定义在 `world body`**（世界坐标系对应的顶级 `body` ）上，因为 `world body` 是运动学树的根，没有父 `body` ，无法与之形成相对运动。

下面来讲一下该节点下的一些元素及其用法：



#### **4.2、name：**

​		你所创建的joint的名字（如果是从sw中导出URDF再转成MJCF时，其name自动变为导出URDF时命名的joint）；



#### **4.3、type：**

​		该元素用于定义关节的 “运动自由度类型”，每种类型对应不同的运动逻辑和约束（必填）。

**`type` 的作用：决定关节的 “自由度与运动方式”**

- **自由度（DOF）**：允许几个方向运动（平移 / 旋转）；
- **运动形式**：平移、旋转的具体逻辑（如绕轴转、沿轴滑）；
- **约束规则**：能否与其他关节共存、是否有位置限制等。

其可选项有四种：分别为free，ball，slide，hinge（默认为hinge）；下面来讲讲这四种类型的用法：

**1）、free（自由关节）：**

- **自由度**：6 DOF（3 平移 + 3 旋转 ）→ 物体完全 “漂浮”，可自由移动和旋转。
- **旋转表示**：用**单位四元数**描述旋转（`(1,0,0,0)` 对应初始姿态 ）。
- **约束规则**：
  - 只能附加到 `world body` 的子节点（直接挂在世界坐标系下 ）；
  - 一个 `body` 只能有 1 个 `free` 关节，且不能有其他关节；
  - 关节位置默认与 `body` 的质心重合（无独立关节位置，直接用 `body` 位姿 ）；
  - **无运动限制**（不能设 limits ）。
- **典型场景**：模拟空中漂浮的物体（如无人机、悬浮机器人 ）。

该关节一般不用；

**2）、ball（球形关节）：**

- **自由度**：3 DOF（仅旋转，无平移 ）→ 物体可绕固定点做任意方向旋转。
- **旋转表示**：用**单位四元数**描述旋转（`(1,0,0,0)` 对应初始姿态 ）。
- **约束规则**：
  - 旋转围绕 `pos` 属性指定的点；
  - 一个 `body` 若有 `ball` 关节，则**不能有其他旋转关节**（`ball` 或 `hinge` ）；
  - 可与 `slide` 关节共存（允许平移 + 球旋转组合 ）。
- **典型场景**：模拟肩关节、髋关节（多方向旋转，但位置固定 ）。

**3）、slide（滑动关节/移动关节）：**

- **自由度**：1 DOF（仅平移，无旋转 ）→ 物体沿固定方向滑动。
- **参数逻辑**：
  - 由 `pos`（关节位置，仅用于可视化 ）和 `axis`（滑动方向 ）定义；
  - 仿真时**仅需方向**，位置主要用于渲染。
- **典型场景**：模拟抽屉滑动、电梯升降、活塞运动。

**4）、hinge（铰链关节）：**

- **自由度**：1 DOF（仅旋转，无平移 ）→ 物体绕固定轴旋转。
- **参数逻辑**：
  - 旋转围绕 `pos` 指定的点，沿 `axis` 指定的轴（如 `(0,0,1)` 表示绕 Z 轴 ）。
- **约束规则**：
  - 最常用的关节类型，可设 `limits`（限制旋转角度范围 ）；
  - 一个 `body` 可叠加多个 `hinge` 关节（按定义顺序叠加变换 ）。
- **典型场景**：模拟门铰链、机械臂旋转关节、 pendulum 单摆。

**该关节是最常用的；**



#### **4.4、pos：**

​		该元素用于 **定义关节在其所属 `body` 坐标系中的位置** ，是确定关节空间位置的关键配置，影响关节运动的参考点，但对 `free` 关节无效。

**1）. 坐标系参考：**

`pos` 的取值是一个长度为 3 的实数数组（`real(3)` ），表示关节在**其所属 `body` 的局部坐标系**中的位置。例如，若 `body` 的局部坐标系原点在世界坐标系中是 `(1,1,1)`，`pos="0.5 0.5 0.5"` 则关节在世界坐标系中的位置是 `(1.5, 1.5, 1.5)` 。

**2）. 对 `free` 关节的特殊处理：**

当关节类型是 `free`（自由关节 ）时，`pos` 属性会被**忽略** 。因为 `free` 关节的位置默认与所属 `body` 的质心重合，无需（也无法 ）单独指定关节位置。

**3）. 对其他关节的影响：**

对于 `ball`（球关节 ）、`slide`（滑动关节 ）、`hinge`（铰链关节 ）：

- `pos` 决定了关节运动的 “参考点”。比如 `hinge` 关节绕轴旋转时，会围绕 `pos` 定义的点转动；`ball` 关节的旋转中心就是 `pos` 点；`slide` 关节的滑动路径会经过 `pos` 点（主要用于可视化，仿真时方向起关键作用 ）。

其实该节点我们并不用管，在我们从URDF转MJCF时，会自动计算pos；



#### **4.5、axis：**

​		该元素用于 **定义关节的运动方向 / 轴** ，仅对 `hinge`（铰链关节 ）和 `slide`（滑动关节 ）有效，决定关节是绕哪个轴旋转（`hinge` ）或沿哪个方向平移（`slide` ），是控制这两类关节运动方式的关键配置。

 **1）、适用关节类型：**

- **`hinge` 关节**：`axis` 定义关节的**旋转轴**，关节将围绕该轴进行转动。
- **`slide` 关节**：`axis` 定义关节的**平移方向**，关节将沿该方向滑动。
- **`free` 和 `ball` 关节**：`axis` 会被忽略，因为这两类关节的运动自由度不依赖单一固定轴 / 方向（`free` 是 6 自由度，`ball` 是 3 旋转自由度 ）。

**2）、 向量归一化与编译检查：**

- `axis` 的取值是长度为 3 的实数数组（`real(3)` ），表示一个 3D 向量。
- Mujoco 会自动将该向量**归一化为单位长度**（只要向量长度大于 `10E-14` ，避免数值过小导致计算问题 ）。
- 若向量长度过小（≤ `10E-14` ，接近零向量 ），会触发**编译错误** ，因为无法明确运动方向 / 轴。

该元素在我们导出URDF时所创建的坐标系，在转MJCF时会自动计算；

其参数为real（3），分别表示XYZ，依次生成一个向量，来表示选择轴



#### **4.6、range：**

​		该元素用于确定该关节的活动范围；需要先在**compiler**里指定**autolimits**（true），这样关节限制才能被启用；

real（2）：表示活动的区间，最小值，最大值；



#### **4.7、limited：**

​		此属性指定关节是否限制；（只有当我们没有在**compiler**里指定**autolimits**（true）时，该元素就必须为true，才能启用关节限制）



#### **4.8、actuatorfrcrange：**

​		该元素用于**限制作用在关节上的执行器总力的范围** ，仅对 `hinge`（铰链关节 ）和 `slide`（滑动关节 ）有效，是控制关节受力极限、避免物理仿真异常的关键配置。

**适用关节类型：**

仅对 **标量关节**（`hinge` 和 `slide` ，分别对应 1 个旋转、1 个平移自由度 ）有效，对 `ball`（3 旋转自由度 ）和 `free`（6 自由度 ）关节无效（会被忽略 ）。

**参数格式与含义：**

`actuatorfrcrange: real(2), "0 0"` 表示需填入 **两个实数**，定义力的 “最小值” 和 “最大值”，形式为 `[min_force, max_force]` ：

- 仿真时，作用在该关节的执行器总力会被 “钳位” 在这个范围内，即力不会小于 `min_force` ，也不会大于 `max_force` 。

使用该元素时，必须在`compiler`里指定`autolimits`为true；





### **5、site子节点：**

​		简易版geom，不作为碰撞体积和质量计算，只能使用简易几何体，适用于在某些小部位安装传感器或者小结

构渲染等，其属性和geom非常相近；

​		使用方法和geom一样；

**与 `geom` 的关系：简化版几何：**

- **继承与限制**：`site` 可使用部分 `geom` 的属性（如形状、颜色 ），但功能更精简。

- 核心差异

  ：

  - `site` **不参与碰撞**（不会与其他物体产生接触力 ）；
  - `site` **不影响刚体质量、惯性**（即使有形状，也不计入惯性推导 ）。

**语义与作用：标记 “感兴趣的位置”：**

`site` 的核心是**在刚体坐标系中标记一个 “关键点”** ，常见用途：



- 挂载传感器（如力传感器、视觉传感器 ）；
- 定义 tendon（肌腱 / 绳索 ）的途经点（via-points ）；
- 构建特殊传动结构（如 slider-crank 传动 ）；
- 可视化标记（如在刚体特定位置显示一个小球，辅助调试 ）。

**形状限制：仅支持部分 `geom` 类型：**

虽然 `site` 可用形状渲染，但支持的类型比 `geom` 少（如仅支持 `sphere`、`capsule` 等基础形状 ），且形状仅用于**可视化和标记**，不参与物理计算。





### **6、总结：**

​		该节点可谓是mujoco中最重要的节点，用于创建body来进行物理学运动仿真；

下面附上一则代码：

~~~html
<?xml version="1.0" encoding="utf-8"?>
<mujoco model="inverted_pendulum">
    <compiler angle="radian" meshdir="meshes" autolimits="true" />
    <option timestep="0.002" gravity="0 0 -9.81" wind="0 0 0" integrator="implicitfast"
        density="1.225"
        viscosity="1.8e-5" />

    <visual>
        <global realtime="1" />
        <quality shadowsize="16384" numslices="28" offsamples="4" />
        <headlight diffuse="1 1 1" specular="0.5 0.5 0.5" active="1" />
        <rgba fog="1 0 0 1" haze="1 1 1 1" />
    </visual>

    <asset>
        <mesh name="tetrahedron" vertex="0 0 0 1 0 0 0 1 0 0 0 1" />
        <mesh file="card.obj" scale="1 1 1" />
        <texture type="2d" file="./king_of_clubs.png" />
        <material name="king_of_clubs" texture="king_of_clubs" />
        <hfield name="agent_eval_gym" file="agent_eval_gym.png" size="10 10 1 1" />
        <texture type="skybox" file="../asset/desert.png"
            gridsize="3 4" gridlayout=".U..LFRB.D.." />
        <texture name="plane" type="2d" builtin="checker" rgb1=".1 .1 .1" rgb2=".9 .9 .9"
            width="512" height="512" mark="cross" markrgb=".8 .8 .8" />
        <material name="plane" reflectance="1" texture="plane" texrepeat="1 1" texuniform="true" />
        <material name="box" rgba="0 0.5 0 1" emission="1" />
    </asset>

    <default>
        <geom solref=".5e-4" solimp="0.9 0.99 1e-4" fluidcoef="0.5 0.25 0.5 2.0 1.0" />
        <default class="card">
            <geom type="mesh" mesh="card" mass="1.84e-4" fluidshape="ellipsoid" contype="0"
                conaffinity="0" />
        </default>
        <default class="collision">
            <geom type="box" mass="0" size="0.047 0.032 .00035" group="3" friction=".1" />
        </default>
    </default>

    <worldbody>
        <geom name="floor" pos="0 0 0" size="0 0 .1" type="plane" material="plane"
            condim="3" />
        <light directional="true" ambient=".3 .3 .3" pos="30 30 30" dir="0 -2 -1"
            diffuse=".5 .5 .5" specular=".5 .5 .5" />

        <body pos="0 0 1" euler="-45 45 0">
            <freejoint />
            <geom class="card" material="king_of_clubs" />
            <geom class="collision" />
        </body>

        <geom type="hfield" hfield="agent_eval_gym" pos="0 11 0" />


        <body pos="-1 0 .5">
            <freejoint />
            <geom type="sphere" size="0.1" rgba=".5 0 0 1" />
            <site type="capsule" size="0.05 0.1" rgba="0 0 .5 1" />
        </body>
        <body pos="-0.5 0 .5">
            <freejoint />
            <geom type="box" size="0.1 0.1 0.1" material="box" density="1" contype="2"
                conaffinity="3" />
        </body>
        <!-- <body pos="0 0 .5">
            <freejoint />
            <geom type="capsule" size="0.1 0.1" rgba="0 0 .5 1" />
        </body> -->
        <body pos=".5 0 .5">
            <freejoint />
            <geom type="cylinder" size="0.1" fromto="0 0 0 0 0 0.2" rgba=".5 .5 0 1" />
        </body>
        <body pos="1 0 .5">
            <freejoint />
            <geom type="ellipsoid" size="0.2 0.2 0.1" rgba="0 .5 .5 1" />
        </body>
        <body pos="1.5 0 .5">
            <freejoint />
            <geom type="ellipsoid" size="0.2 0.1 0.1" rgba=".5 0 .5 1" />
        </body>

        <body pos="2.0 0 .5">
            <freejoint />
            <geom type="mesh" mesh="tetrahedron" rgba=".5 .5 .5 1" />
        </body>

        <!-- <body name="A" pos="0 0 2" euler="0.5 0 0">
            <freejoint />
            <geom type="sphere" size="0.1" rgba=".2 0 0 1" />
            <body name="B" pos="0 0 0.5" euler="0.5 0 0">
                <geom type="capsule" size="0.05 0.1" rgba="0 0 .2 1" />
            </body>
        </body> -->

    </worldbody>
</mujoco>
~~~

具体这样的：

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340922.png)









## **八、tendon节点：**

​		肌腱的作用就是将关节组合映射，可以将多个关节组合成一个控制器进行控制。最简单的用法可以看官方模型的car.xml。这个模型将左轮和右轮统一映射成了向前和旋转两个控制器对车辆进行控制。如果作为麦轮或者全向轮来说可以分成x，y，roat这三个控制器；

主要分为两个类型的：**spatial（肌肉类型）**和**fixed（电机类型）**：

主要讲解一下fixed：

使用tendon组合关节映射的时候，要使用tendon下面的fixed节点。fixed中包含关节的映射关系。

fixed中joint为制定关节，coed为缩放系数。原理就是使用fixed组合之后，**控制器不再使用关节控制，而是将数据传给tendon/fixed，通过code缩放参数后给joint；**

### **1、fixed子节点：**

​		该节点用于定义**抽象肌腱**，其核心是通过关节位置 / 角度的线性组合计算肌腱长度，常用于模拟机械耦合、自定义约束或简化复杂肌腱行为。

​		一般我们只用该节点下的子节点joint，对多个关节组合成一个控制器合成（不过我感觉这个东西很鸡肋，因为肌腱的长度问题，及后面所讲的coef）；

#### **1.1、joint：**

​		关联的关节名称（必须是slide或hinge类型的标量关节）；我们在body中创建的joint的名字；



#### **1.2、coef：**

​		关节位置or角度的系数（线性组合权重）；









## **九、actuator节点：**

​		如果说worldbody节点是仿真的基础，那么这个就是仿真的核心所在，没有该节点我们就无法使我们的机器人动起来；该节点**是运动控制节点，在这里指定驱动器，给机器人加入“肌肉”**；

下面来讲一下，在该节点下有那些控制方式：

### **1、general子节点：**

​		该节点用于创建**通用执行器**，核心是**让用户完全自定义执行器的所有组件**，摆脱预设执行器（如 `motor`/`muscle`）的限制。

`actuator/general` 的最大特点是 **“全开放”**：

- 不像 `motor`（仅驱动关节）、`muscle`（仅模拟肌肉力学）等预设执行器有固定逻辑，`general` 允许你**独立配置执行器的所有组件**（如控制信号、力生成、反馈机制等）。
- 适合需要**精细控制执行器物理行为**，或模拟特殊执行器（如气动、液压、自定义智能驱动）的场景。

一般我们不会去使用该节点，但配置其他控制方式，也会采用共同的节点；

#### **1.1、name：**

​		为你所创建的驱动器命名；



#### **1.2、joint：**

​		因为驱动器一般是放在joint上，所以该元素用于填写挂载joint的名字；



#### **1.3、ctrllimited：**

​		该元素决定了**执行器的“控制输入”是否会被自动限制在 `ctrlrange` 定义的范围内**。

`ctrllimited` 支持三个取值：`false` / `true` / `auto`，行为各有不同：

**1. `ctrllimited="false"`：**

- **行为**：关闭控制输入限幅，控制信号可以完全突破 `ctrlrange` 的限制。
- **风险**：可能导致执行器 “超量程”，引发物理仿真异常（如关节受力过大断裂、肌肉过度拉伸）。
- **适用场景**：需刻意模拟 “执行器失控”“超极限测试” 等特殊情况。

**2. `ctrllimited="true"：`**

- **行为**：强制开启限幅，控制信号会被严格截断到 `ctrlrange` 范围内（无论 `compiler` 如何配置）。
- **效果**：假设 `ctrlrange="[-1, 1]"`，若输入控制信号为 `1.5`，则实际执行器收到的信号会被截断为 `1`。
- **适用场景**：需要严格限制执行器的控制输入（如工业机械臂、安全关键系统）。

**3. `ctrllimited="auto"：`**

- 行为

  ：是否限幅由compiler中的autolimits和ctrlrange是否定义共同决定：

  - 若 `compiler` 启用 `autolimits`，且模型中**定义了 `ctrlrange`**，则 `ctrllimited` 自动为 `true`（开启限幅）。
  - 若没定义 `ctrlrange`，或 `compiler` 未启用 `autolimits`，则 `ctrllimited` 为 `false`（关闭限幅）。

- **优势**：无需手动设置 `true`/`false`，由模型配置自动推断，适合 “常规仿真” 场景。

该参数一般不用我们特别的写出来；



#### **1.4、forcelimited：**

​		该元素决定了 **执行器的输出力是否会被自动限制在 `forcerange` 定义的范围内**。

`forcelimited` 支持 `false` / `true` / `auto` 三个值，行为各有不同：

**1. `forcelimited="false"：`**

- **效果**：关闭力输出限幅，执行器可输出任意大小的力（不受 `forcerange` 限制）。
- **风险**：可能导致执行器 “超功率” 运行，引发物理仿真异常（如关节受力过大损坏、刚体因力过大穿透）。
- **适用场景**：需刻意模拟 “执行器过载”“极端力测试” 等特殊情况（如碰撞实验、极限工况）。

**2. `forcelimited="true"：`**

- **效果**：强制开启限幅，执行器输出力会被严格截断到 `forcerange` 范围内（无论其他配置如何）。
- **示例**：若 `forcerange="[-50, 50]"`，执行器计算出的输出力为 `60`，则实际输出会被截断为 `50`。
- **适用场景**：需要严格限制执行器的力输出（如精密机械、生物仿真避免肌肉 / 肌腱断裂）。

**3. `forcelimited="auto"`：**

- 效果

  ：是否限幅由compiler中的autolimits和forcerange是否定义共同决定：

  - 若 `compiler` 启用 `autolimits`，且模型中**定义了 `forcerange`**，则 `forcelimited` 自动为 `true`（开启限幅）。
  - 若没定义 `forcerange`，或 `compiler` 未启用 `autolimits`，则 `forcelimited` 为 `false`（关闭限幅）。

- **优势**：无需手动设置 `true`/`false`，由模型配置自动推断，适合 “常规仿真” 场景。



#### **1.5、ctrlrange：**

​		该元素用于控制输入角度范围；（第一个值必须小于第二个值）



#### **1.6、forcerange：**

​		该元素用于控制输出力的范围；（第一个值必须小于第二个值）



#### **1.7、dyntype：**

​		执行器（actuator）的一个关键属性，用于定义执行器的**激活动力学类型**，决定执行器的激活状态（activation）如何随控制输入（ctrl）动态变化 。

​		它有 `none`、`integrator`、`filter`、`filterexact`、`muscle`、`user` 等取值，不同取值对应不同的动力学计算方式，进而影响执行器的动态响应特性。

下面来讲讲不同取值（**默认为none**）：

- **`none`：**
  - 描述为 “No internal state”，即执行器没有内部状态。这意味着激活状态 `act` 通常直接由控制输入 `ctrl` 决定（无动态变化过程 ），简单来说，控制输入能瞬间、直接地决定执行器的激活程度，没有延迟、积分等动态响应。比如，给执行器一个控制信号，激活状态马上就变成对应的值，常用于简单、不需要模拟动态响应的场景。
- **`integrator`：**
  - 动力学方程为 `act_dot = ctrl`（`act_dot` 是 `act` 对时间的导数 ）。这表示激活状态的变化率等于控制输入。积分这个方程可得 `act = ∫ctrl dt`（初始条件合适时 ），也就是说，激活状态是控制输入的积分。例如，若控制输入 `ctrl` 是一个恒定值，激活状态会随时间线性增长，常用于需要模拟执行器激活程度随控制信号累积变化的场景，像模拟某些需要 “蓄力” 、状态持续变化的执行器行为。
- **`filter`：**
  - 动力学方程为 `act_dot = (ctrl - act) / dynprm[0]` 。这里 `dynprm[0]` 是一个参数（属于执行器的动态参数，需另外配置合理数值 ），可以把它理解为 “时间常数” ，决定了激活状态趋近于控制输入的速率。该模型下，激活状态会以指数形式趋近于控制输入 `ctrl` 。比如，当 `dynprm[0]` 较小，激活状态会快速跟上控制输入的变化；`dynprm[0]` 较大时，响应就比较缓慢，常用于模拟执行器存在一定 “惯性” 、激活状态不能瞬间跟上控制信号变化的情况，像简单模拟电机的响应延迟、肌肉激活的渐变过程等。
- **`filterexact`：**
  - 描述为 “Like filter but with exact integration”，即和 `filter` 类似，但采用精确积分的方式计算激活状态的变化。在数值仿真中，普通的 `filter` 可能会因为数值积分方法（如欧拉积分等近似方法 ）存在一定误差，`filterexact` 则会采用更精确的积分手段来计算 `act` 的变化，让激活状态的动态响应更贴近理论上的动力学方程，适合对仿真精度要求较高，需要更准确模拟执行器动态特性的场景。
- **`muscle`：**
  - 动力学方程为 `act_dot = mju_muscleDynamics(...)` ，即调用 MuJoCo 内置的肌肉动力学函数来计算激活状态的变化率。这是专门用于模拟生物肌肉激活动力学的模型，会考虑肌肉激活的生理特性，比如肌肉激活的延迟、肌肉的疲劳（如果相关函数实现了的话 ）、以及肌肉激活和松弛的不对称性等复杂行为，常用于生物力学仿真（如模拟人形机器人、动物运动模型中的肌肉动态 ）。
- **`user`：**
  - 动力学方程为 `act_dot = mjcb_act_dyn(...)` ，这里 `mjcb_act_dyn` 是用户自定义的回调函数。也就是说，用户可以自己编写代码（通常结合 MuJoCo 的 C API ），定义激活状态变化率的计算逻辑，高度灵活，能用于模拟特殊的、MuJoCo 内置动力学模型无法涵盖的执行器动态，比如自定义的智能执行器模型、特殊物理效应的执行器等。



#### **1.8、gaintype：**

​		该元素是执行器（actuator）的关键属性，用于**定义执行器 “力生成机制” 的增益计算方式**，决定执行器如何将控制信号（或激活状态）转换为输出力。

​	执行器的最终输出力由**增益（gain）、偏置（bias）和控制信号 / 激活状态**共同决定，公式为： 

​									**scalar_force = gain_term * (act or ctrl) + bias_term**

- \(act\)：执行器的激活状态（由 `dyntype` 定义的动力学决定）
- (ctrl)：直接控制信号（若没有激活状态则用此）
- (gain\_term)：增益项（由 `gaintype` 决定计算方式）

`gaintype` 支持 `fixed` / `affine` / `muscle` / `user` 四个值，对应不同的增益计算逻辑：（**默认为fixed**）

**1. `gaintype="fixed"`：**

- **公式**：gain_term = gainprm[0]
- **含义**：增益项是**固定值**，仅由 `gainprm` 的第一个参数决定。
- **示例**：若 `gainprm="100"`，则 (gain_term = 100)，输出力与控制信号成简单比例关系。
- **适用场景**：执行器力输出与控制信号线性关联（如普通电机、简单液压执行器）。

2. **`gaintype="affine"`：**

- **公式**：gain_term = gainprm[0] + gainprm[1] * length + gainprm[2] * velocity
- **含义**：增益项是 **“长度 + 速度” 的线性组合 **，需额外配置 `length`（执行器长度，如肌腱长度）和 `velocity`（执行器速度，如关节角速度）。
- **示例**：`gainprm="50 0.1 0.05"`，则 (gain_term = 50 + 0.1 * length + 0.05 * velocity)。
- **适用场景**：执行器力输出与自身长度、运动速度相关（如弹性执行器、含阻尼的机械装置）。

**3. `gaintype="muscle"`：**

- **公式**：gain_term = mju_muscleGain(...)
- **含义**：调用 MuJoCo 内置的**肌肉增益函数**，模拟生物肌肉的复杂力学特性（如长度 - 张力关系、激活 - 力非线性）。
- **依赖**：需配合 `muscle` 类型的执行器（`actuator/muscle`），自动关联肌肉的生理参数。
- **适用场景**：生物力学仿真（如人形机器人、动物运动模型），需精确模拟肌肉的力生成机制。

**4. `gaintype="user"`：**

- **公式**：gain_term = mjcb_act_gain(...)
- **含义**：调用**用户自定义的增益函数**，完全由用户编写代码控制增益计算逻辑。
- **实现**：需通过 MuJoCo 的 C API 注册回调函数 `mjcb_act_gain`，自定义增益计算。
- **适用场景**：特殊执行器（如气动、磁悬浮）或自定义物理模型，内置增益逻辑无法满足需求。



#### **1.9、biastype：**

​		该元素是执行器（actuator）的关键属性，用于**定义执行器 “偏置力（bias force）” 的计算方式**，决定执行器输出力中 “基础偏移量” 的生成逻辑。

执行器的最终输出力公式为：

​										**scalar_force = gain_term * (act or ctrl) + bias_term**

- (bias_term)：即 “偏置力”，是执行器输出力的**基础偏移量**（与控制信号 / 激活状态无关的恒定或动态项）。
- `biastype` 决定 (bias\_term\) 的计算方式，可模拟执行器的 “固有偏移”“环境依赖偏移” 或 “自定义偏移”。

`biastype` 支持 `none` / `affine` / `muscle` / `user` 四个值，对应不同的偏置力计算逻辑：（**默认为none**）

**1. `biastype="none"`：**

- **公式**：bias_term = 0
- **含义**：无偏置力，执行器输出力仅由 `gain_term` 和控制信号 / 激活状态决定。
- **示例**：若 `gaintype="fixed"` 且 `gainprm="100"`，则 (force = 100 * ctrl)。
- **适用场景**：执行器无固有偏移（如理想电机、简化模型）。

**2. `biastype="affine"`：**

- **公式**：bias_term = biasprm[0] + biasprm[1] * length + biasprm[2] * velocity
- **含义**：偏置力是 **“长度 + 速度” 的线性组合 **，需额外配置 `length`（执行器长度，如肌腱长度）和 `velocity`（执行器速度，如关节角速度）。
- **示例**：`biasprm="10 0.5 0.2"`，则 \(bias_term = 10 + 0.5 * length + 0.2 * velocity\)。
- **适用场景**：执行器偏置力与自身长度、运动速度相关（如含预紧力的弹簧、带阻尼的机械装置）。

**3. `biastype="muscle"`：**

- **公式**：\bias_term = mju_muscleBias(...)
- **含义**：调用 MuJoCo 内置的**肌肉偏置函数**，模拟生物肌肉的固有偏置（如肌肉静息张力、长度 - 张力基线）。
- **依赖**：需配合 `muscle` 类型的执行器（`actuator/muscle`），自动关联肌肉的生理参数。
- **适用场景**：生物力学仿真（如人形机器人、动物运动模型），需精确模拟肌肉的固有偏置。

**4. `biastype="user"`：**

- **公式**：\(bias_term = mjcb_act_bias(...)\)
- **含义**：调用**用户自定义的偏置函数**，完全由用户编写代码控制偏置力计算逻辑。
- **实现**：需通过 MuJoCo 的 C API 注册回调函数 `mjcb_act_bias`，自定义偏置计算。
- **适用场景**：特殊执行器（如气动、磁悬浮）或自定义物理模型，内置偏置逻辑无法满足需求。



#### **1.10、dyntype：**

​		是 MuJoCo 中与执行器（actuator）激活动力学相关的参数数组，用于为执行器的激活动力学（由 `dyntype` 定义 ）提供配置参数 。它本质上是一组实数（`real`）构成的数组，长度理论上可灵活设置（解析器不强制限制长度 ），用于精细调节执行器激活状态随时间变化的动态行为。（长度为10）

**作用场景与关联对象；**

- **关联 `dyntype`**：它是为执行器的激活动力学服务的，不同的 `dyntype`（如 `integrator`、`filter` 等 ）会用到 `dynprm` 里的参数来计算激活状态的变化率（`act_dot` ）。例如，当 `dyntype = "filter"` 时，`dynprm` 的第一个参数会参与到 `act_dot = (ctrl - act) / dynprm[0]` 这个动力学方程的计算中，决定激活状态趋近于控制输入的速率。
- **针对非肌肉激活类型**：内置的激活类型（除了 `muscle` 类型 ）通常主要使用 `dynprm` 的第一个参数，但也预留了额外参数位置，方便用户通过自定义回调函数（user callbacks ）实现更复杂的激活动力学模型时使用。也就是说，如果用户觉得 MuJoCo 内置的激活动力学不够用，想自己写代码定义更 elaborate（精细、复杂 ）的模型，就可以利用 `dynprm` 里预留的额外参数传递所需的配置。
- **与肌肉执行器不兼容**：这些默认的 `dynprm` 配置不适用于肌肉类型的执行器（`muscle actuators` ），如果要配置肌肉执行器的动力学参数，需要参考专门的 `muscle` 相关文档部分（文中提到的 “see muscle below” ），因为肌肉执行器有其特有的动力学模型和参数配置要求。



#### **1.11、gainprm**：

​		**`gainprm` 是执行器（actuator）的关键参数数组，用于**配置 “增益模型” 的参数**，决定执行器如何将控制信号转换为输出力。**

- gain\_term：由 `gaintype` 定义的**增益模型**计算，`gainprm` 为该模型提供参数。
- 简单说：`gainprm` 是 `gaintype` 的 “配置参数数组”，不同 `gaintype` 会读取 `gainprm` 中的值计算增益。

**内置增益模型（除 `muscle` 外）：**

- 对于 `gaintype="fixed"` / `affine`（非肌肉类型），**仅使用 `gainprm` 的第一个参数**。
- 示例：`gaintype="fixed"` 时，gain_term = gainprm[0]。

**预留额外参数（用户自定义）：**

- 若通过 `user` 类型自定义增益模型（`gaintype="user"`），`gainprm` 可包含**任意数量的参数**，供用户回调函数（`mjcb_act_gain`）读取。
- 解析器不限制 `gainprm` 的长度，用户可根据需求灵活扩展。

**肌肉执行器不兼容：**

- 若 `gaintype="muscle"`（肌肉类型），`gainprm` 的默认配置**不适用**，需参考 `muscle` 专属文档配置参数。



#### **1.12、biasprm：**

​		`biasprm` 是执行器（actuator）的关键参数数组，用于**配置 “偏置力模型” 的参数**，决定执行器输出力中 “基础偏置项” 的计算逻辑。

- bias\_term：由 `biastype` 定义的**偏置模型**计算，`biasprm` 为该模型提供参数。
- 简单说：`biasprm` 是 `biastype` 的 “配置参数数组”，不同 `biastype` 会读取 `biasprm` 中的值计算偏置力

**`biastype="affine"`（仿射偏置）：**

- 需用**3 个参数**：bias\_term= biasprm[0] + biasprm[1] * length + biasprm[2] * velocity。
- 示例：`biasprm="10 0.5 0.2"`，则 bias_term = 10 + 0.5 * length + 0.2 * velocity。

**其他类型（`none` / `muscle` / `user`）：**

- `biastype="none"`：无需参数bias_term = 0 ，`biasprm` 无效。
- `biastype="muscle"`：默认参数不适用，需参考 `muscle` 专属文档配置。
- `biastype="user"`：参数数量灵活，供用户回调函数（`mjcb_act_bias`）读取。

**解析器不限制长度：**

- `biasprm` 的长度由用户需求决定，解析器不会强制校验。
- 但需确保参数数量与 `biastype` 匹配（如 `affine` 需 3 个参数），否则仿真可能异常。



#### **1.13、gear：**

​		



### **2、motor子节点：**

​		`actuator/motor` 是 MuJoCo 中**电机执行器的 “快捷方式”**（Actuator shortcut），本质是对 `actuator/general` 的封装。它帮你**快速配置 “直接驱动电机”**，无需手动设置 `general` 执行器的所有参数，适合常规电机仿真。

当解析器遇到 `actuator/motor` 时，会自动：

1. **创建 `general` 执行器**：将 `motor` 的配置转换为 `general` 的属性。
2. **设置默认参数**：覆盖 `dynprm`、`gainprm`、`biasprm` 为内置默认值（见表格）。
3. **调整动力学类型**：自动设置 `dyntype`、`gaintype`、`biastype`，匹配电机的 “直接驱动” 特性。

**其他的属性均保持默认，可自行再配置；**

该快捷方式为电机的力矩控制；

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340359.png)

该节点没有其自己的所属元素，仅继承general的元素；



### **3、position子节点 ：**

​		`actuator/position` 是 MuJoCo 中**位置伺服执行器**的快捷配置，核心功能是：

- 驱动关节 / 肌腱**跟踪目标位置**，模拟 “位置控制器 + 一阶滤波器” 的行为。
- 自动封装 `actuator/general` 的复杂参数，简化位置伺服的配置。

解析器遇到 `actuator/position` 时，会自动：

1. **创建 `general` 执行器**：将 `position` 的配置转换为 `general` 的属性。
2. **设置默认参数**：根据位置伺服的逻辑，预填 `dyntype`、`gaintype`、`biastype` 等参数（见表格）。
3. **支持一阶滤波器**：通过 `dyntype="filterexact"` 或 `none` 可选一阶滤波，平滑位置跟踪过程。

**其他的属性均保持默认，可自行再配置；**

![](https://cdn.jsdelivr.net/gh/KKMJJ0721/Blog_pic/202509041340571.png)

| `position` 隐含的 `general` 属性 | 设置值                | 含义                                                         |
| -------------------------------- | --------------------- | ------------------------------------------------------------ |
| dyntype                          | none` 或 `filterexact | 选择是否启用一阶滤波器：<br/>\- `none`：无滤波，直接位置控制。<br/>\- `filterexact`：启用一阶滤波，平滑响应。 |
| gaintype                         | fixed                 | 增益为固定值（`gainprm[0] = kp`），输出力与位置误差线性关联。 |
| biastype                         | affine                | 偏置力为仿射模型（`biasprm = [0, -kp, -kv]`），包含比例 - 速度补偿。 |
| dynprm                           | timeconst 0 0         | 动力学参数，`timeconst` 是一阶滤波器的时间常数（仅 `filterexact` 生效）。 |
| gainprm                          | kp 0 0                | 增益参数，`kp` 是位置控制器的比例增益。                      |
| biasprm                          | 0 -kp -kv             | 偏置参数，`-kp` 补偿位置误差，`-kv` 补偿速度（阻尼项）。     |

位置伺服的核心公式（简化）：
force = kp * ( target_pos − current_pos ) − kv * joint_velocity

下面来讲一下该节点的三个附属元素：

#### **3.1、Kp：**

​		`kp` 是 `actuator/position` 执行器的**位置反馈比例增益**，用于控制 “位置误差 → 输出力” 的放大倍数。

位置伺服的控制逻辑可简化为：

​				**force=kp * (目标位置 − 当前位置) − kv * 关节速度**

- `kp` 越大：位置误差对输出力的影响越显著，执行器越 “刚性”（跟踪精度高，但可能震荡）。
- `kp` 越小：位置误差对输出力的影响越弱，执行器越 “柔性”（跟踪精度低，但更稳定）。

- **高 `kp`（如 100）**：
  - 优点：位置跟踪精度高（小误差也会产生大力，快速纠正偏差）。
  - 缺点：易引发震荡（微小的位置变化会被放大，导致执行器反复调整）。
- **低 `kp`（如 10）**：
  - 优点：系统更稳定（误差对力的影响小，避免震荡）。
  - 缺点：跟踪精度低（大误差才会产生明显力，响应缓慢）。



#### **3.2、Kv：**

​		`kv` 是 `actuator/position` 执行器的**速度阻尼增益**，用于模拟执行器对 “关节速度” 的阻力（或阻尼），核心作用是**抑制震荡**。

位置伺服的控制逻辑可简化为：

​				**force=kp * (目标位置 − 当前位置) − kv * 关节速度**

- `kv` 越大：关节速度对输出力的影响越显著，执行器的 “阻尼感” 越强（可快速抑制震荡）。
- `kv` 越小：关节速度对输出力的影响越弱，阻尼感越弱（可能导致震荡）。

- **高 `kv`（如 20）**：
  - 优点：强阻尼，快速抑制执行器的震荡（如机械臂关节快速停止摆动）。
  - 缺点：可能导致响应延迟（阻尼过强会阻碍关节运动）。
- **低 `kv`（如 5）**：
  - 优点：弱阻尼，关节运动更灵活（适合需要快速响应的场景）。
  - 缺点：易引发震荡（如机械臂关节反复摆动）。



#### **3.3、dampratio：**

​		`dampratio` 是 `actuator/position` 执行器的**阻尼比参数**，用于以 “阻尼比” 为单位配置执行器的阻尼，替代 `kv`，更贴近 “二阶系统（谐波振荡器）” 的阻尼设计逻辑。

阻尼比（damping ratio）是**二阶系统（如弹簧 - 质量 - 阻尼系统）** 的关键参数，决定系统的震荡特性：

- dampratio = 1：**临界阻尼**，系统无震荡，快速稳定（最常用）。
- dampratio < 1：**欠阻尼**，系统会震荡（震荡幅度随比值减小而增大）。
- dampratio > 1：**过阻尼**，系统无震荡，但稳定时间更长。

- 当设置 `dampratio` 时，`kv` 会被自动计算为：

​												**kv = dampratio * 2 *（kp * m）½**



#### **3.4、timeconst：**

​		`timeconst` 是 `actuator/position` 执行器中**一阶滤波器（first-order filter）** 的时间常数，用于控制位置伺服响应的 “平滑程度”。

- **当 `timeconst > 0`**：
  执行器启用 `filterexact` 动力学类型（一阶滤波器），控制信号会被**平滑滤波**，避免突变。
  - `timeconst` 越大：滤波越强，响应越平滑（但延迟越高）。
  - `timeconst` 越小：滤波越弱，响应越快（但可能保留信号突变）。
- **当 `timeconst = 0`（默认）**：
  执行器禁用滤波器，直接使用 `none` 动力学类型，控制信号无延迟、无平滑。





### **4、总结：**

​		使用该节点时，需注意配置输出限制，并且给出适当的刚度系数和阻尼系数；









## **十、default节点：**

​		`default` 元素用于在 MuJoCo 模型中**创建 “默认配置类”（defaults class）**，核心作用是**集中管理模型元素的默认属性**，实现属性复用、分层继承，简化模型配置。

​		可以让其他节点在使用时调用相同的配置，避免重复手动配置；

可看下面代码：

~~~html
<mujoco model="Gluon_6L3">
  <compiler angle="radian" meshdir="../meshes/" autolimits="true"/>

  <option timestep="0.002" gravity="0 0 -9.81" wind="0 0 0" integrator="implicitfast"
        density="1.225"
        viscosity="1.8e-5" />

  <visual>
        <global realtime="1" />
        <quality shadowsize="16384" numslices="28" offsamples="4" />
        <headlight diffuse="1 1 1" specular="0.5 0.5 0.5" active="1" />
        <rgba fog="1 0 0 1" haze="1 1 1 1" />
  </visual>

  <asset>
    <!-- 机械文件 -->
    <mesh name="base_link" file="base_link.STL"/>
    <mesh name="shoulder_link" file="shoulder_link.STL"/>
    <mesh name="upper_arm_link" file="upper_arm_link.STL"/>
    <mesh name="forearm_link" file="forearm_link.STL"/>
    <mesh name="wrist_1_link" file="wrist_1_link.STL"/>
    <mesh name="wrist_2_link" file="wrist_2_link.STL"/>
    <mesh name="wrist_3_link" file="wrist_3_link.STL"/>
    <!-- 天空盒 -->
    <texture type="skybox" file="A:\mujoco_xml\pictuer\desert.png"
            gridsize="3 4" gridlayout=".U..LFRB.D.." />
    <!-- 地板贴图 -->
    <texture name="plane" type="2d" builtin="checker" rgb1=".1 .1 .1" rgb2=".9 .9 .9"
            width="512" height="512" mark="cross" markrgb=".8 .8 .8" />
    <material name="plane" reflectance="0.3" texture="plane" texrepeat="1 1" texuniform="true" />
  </asset>

  <default>
  <!-- 可视化类 -->
    <default class="visual">
      <geom type="mesh" contype="0" conaffinity="0" group="1" density="0" rgba="0.7 0.7 0.7 1"/>
    </default>
  <!-- 碰撞类 -->
    <default class="collision">
      <!-- 带动力学的碰撞 -->
      <geom type="mesh" contype="1" conaffinity="1" group="0" rgba="0.7 0.7 0.7 1"/>
      <default class="collision1">  
        <!-- 不带动力学的碰撞 -->
        <geom density="0" mass="0"/>
        <default class="collision2">
          <!-- 无碰撞 -->
          <geom contype="0" conaffinity="0"/> 
        </default>
      </default>
    </default>
  </default>

  <worldbody>
  <!-- 地板 -->
    <geom name="floor" pos="0 0 0" size="0 0 .1" type="plane" material="plane" condim="3" />

  <!-- 恢复bash -->
    <body name="bash" pos="0 0 0">
      <geom type="mesh" contype="0" conaffinity="0" group="1" density="0" rgba="1 1 1 1" mesh="base_link"/>
      <geom type="mesh" rgba="1 1 1 1" mesh="base_link"/>

      <body name="shoulder_link" pos="0 0 0.10503">
        <!-- 指定了物体的质量盒转动惯量 -->
        <inertial pos="6.4524e-06 0.013849 -0.011404" quat="0.666906 -0.234989 0.234911 0.666958" mass="0.082019" diaginertia="3.78717e-05 3.0277e-05 2.15943e-05"/>
        <joint name="shoulder_pan_joint" pos="0 0 0" axis="0 0 1" range="-3.14 3.14" actuatorfrcrange="-150 150"/>
        <geom type="mesh" mesh="shoulder_link" class="visual"/>
        <!-- <geom type="mesh" mesh="shoulder_link" class="collision"/> -->

        <body name="upper_arm_link" pos="0 0.080088 0" quat="0.707105 -0.707108 0 0">
          <inertial pos="-6.7051e-10 -0.08721 -0.0079619" quat="0.707107 0.707107 4.06895e-06 5.08922e-06" mass="0.23495" diaginertia="0.00014909 0.00014451 7.2203e-05"/>
          <joint name="shoulder_lift_joint" pos="0 0 0" axis="0 0 1" range="-3.14 3.14" actuatorfrcrange="-150 150"/>
          <geom type="mesh" mesh="upper_arm_link" class="visual"/>
          <geom type="mesh" mesh="upper_arm_link" class="collision"/>

          <body name="forearm_link" pos="0 -0.17442 -0.084515" quat="0.707105 0 0 -0.707108">
            <inertial pos="0.092117 -2.2872e-06 0.011044" quat="0.499985 0.500022 0.49998 0.500013" mass="0.23889" diaginertia="0.00014917 0.00014456 7.2275e-05"/>
            <joint name="elbow_joint" pos="0 0 0" axis="0 0 1" range="-3.14 3.14" actuatorfrcrange="-150 150"/>
            <geom type="mesh" mesh="forearm_link" class="visual"/>
            <geom type="mesh" mesh="forearm_link" class="collision"/>

            <body name="wrist_1_link" pos="0.17442 0 0">
              <inertial pos="0.012755 7.2169e-06 0.069673" quat="-1.0708e-05 0.427548 6.42909e-05 0.903993" mass="0.07333" diaginertia="3.70823e-05 2.9685e-05 2.08717e-05"/>
              <joint name="wrist_1_joint" pos="0 0 0" axis="0 0 -1" range="-3.14 3.14" actuatorfrcrange="-28 28"/>
              <geom type="mesh" mesh="wrist_1_link" class="visual"/>
              <geom type="mesh" mesh="wrist_1_link" class="collision"/>

              <body name="wrist_2_link" pos="0 0 0.080088" quat="0.499998 0.5 0.500002 0.5">
                <inertial pos="6.4506e-06 -0.011404 0.066239" quat="0.637718 0.305503 -0.305411 0.637736" mass="0.082019" diaginertia="3.78717e-05 3.0277e-05 2.15943e-05"/>
                <joint name="wrist_2_joint" pos="0 0 0" axis="0 0 -1" range="-3.14 3.14" actuatorfrcrange="-28 28"/>
                <geom type="mesh" mesh="wrist_2_link" class="visual"/>
                <!-- <geom type="mesh" mesh="wrist_2_link" class="collision"/> -->

                <body name="wrist_3_link" pos="0 0 0.080088" quat="0.707105 -0.707108 0 0">
                  <inertial pos="0 0 -0.037249" quat="0.5 0.5 -0.5 0.5" mass="0.0086882" diaginertia="9.1931e-07 5.9262e-07 5.9262e-07"/>
                  <joint name="wrist_3_joint" pos="0 0 0" axis="0 0 1" range="-3.14 3.14" actuatorfrcrange="-28 28"/>
                  <geom type="mesh" mesh="wrist_3_link" class="visual"/>
                  <geom type="mesh" mesh="wrist_3_link" class="collision"/>
                </body>
              </body>
            </body>
          </body>
        </body>
      </body>
    </body>

  </worldbody>

</mujoco>

~~~









## **十一、sensor节点：**

​		该节点为各种传感器的创建及使用；以后有需要了再来补充；









## **十二、keyframe节点：**

​		`keyframe` 是 MuJoCo 中用于**分组管理 “关键帧（keyframe）”** 的元素，核心作用是：

- 定义一组 “感兴趣的仿真状态”（如机械臂的特定姿态、机器人的初始位置）。
- 这些状态可用于初始化仿真，或作为 “状态库” 在运行时切换。

**关键帧的作用：**

- **保存状态**：记录仿真的关键状态（如关节位置 `qpos`、速度 `qvel`、执行器控制 `ctrl` 等）。
- **初始化仿真**：将仿真初始状态设置为某一关键帧，快速复现特定场景。
- **运行时切换**：通过代码（如 `simulate.cc`）在运行时将仿真状态复制到关键帧，或从关键帧恢复。

**非强制依赖：**

关键帧**不参与 MuJoCo 的核心计算**，仅作为用户自定义的 “状态库”，方便仿真初始化和状态管理。

`keyframe/key` 用于**定义具体的关键帧数据**，每个 `key` 对应一个仿真状态。

**自动排序与索引：**

- `key` 元素按出现顺序自动分配索引（第一个 `key` 是索引 0，第二个是索引 1，依此类推）。
- 关键帧数量由 `size` 元素的 `nkey` 属性和 `key` 元素数量的较大值决定。

**未定义关键帧的默认值：**

若 `key` 元素数量少于 `nkey`，未定义的关键帧默认：

- 所有数据为 `0`，除了 `qpos`（设为 `mjModel.qpos0`，即模型的初始位置）。

下面来讲讲该节点下的元素：

### **1、name：**

​		为你所创建的关键帧命名；



### **2、qpos：**

​		用于**定义关键帧中的关节位置向量**，决定仿真状态切换到该关键帧时，`mjData.qpos`（仿真数据中的关节位置）的值。

当仿真状态切换到某个关键帧时，`qpos` 的值会**覆盖 `mjData.qpos`**，将关节位置设置为关键帧中定义的姿态。

- **示例**：
  若关键帧中 `qpos="0 0.5 1.0"`，切换到该关键帧时，关节位置会被设置为 `[0, 0.5, 1.0]`，直接改变仿真的初始姿态或运行时状态。

- **长度**：`real(mjModel.nq)`，即长度等于模型的关节数量（`mjModel.nq`）。
- **默认值**：`mjModel.qpos0`（模型的初始关节位置，定义在 `<option>` 或模型默认配置中）。

如下：

~~~html
<option>
  <initial keyframe="0"/>  <!-- 加载关键帧 0 的 qpos -->
</option>

<keyframe>
  <key>
    <qpos>0 0.5 1.0</qpos>  <!-- 关键帧 0 的关节位置 -->
  </key>
</keyframe>
~~~



### **3、qvel：**

​		用于**定义关键帧中的关节速度向量** 。当仿真状态切换到该关键帧时，其值会被复制到 `mjData.qvel`（仿真数据中存储关节速度的部分 ），以此来设定关节的速度状态。

- **长度**：`real(mjModel.nq)` ，意味着该向量的长度和模型的关节数量（`mjModel.nq` ）一致，每个元素对应一个关节的速度 。
- **默认值**：`"0 0 ..."` ，也就是默认情况下，若未显式设置 `qvel` ，关键帧中各关节速度初始化为 0 ，即所有关节速度都为 0 向量。

在 `<option>` 中配置 `initial keyframe="n"`（`n` 为关键帧索引 ），仿真启动加载对应关键帧时，该关键帧的 `qvel` 会覆盖 `mjData.qvel` ，作为关节初始速度 。示例如下：

~~~html
<option>
  <initial keyframe="0"/>  <!-- 加载关键帧 0 的状态，包括 qvel -->
</option>

<keyframe>
  <key>
    <qvel>0.2 0.3 0.5</qvel>  <!-- 关键帧 0 中 3 个关节的速度 -->
  </key>
</keyframe>
~~~



### **4、总结：**

​		说实话我感觉该节点的作用不大，不过可以创建一个key来快速复位；









## **十三、equality ：**

`equality` 是 MuJoCo 中用于**分组管理 “等式约束（equality constraints）”** 的元素，核心作用是：

- 逻辑上组织不同类型的等式约束（如 `connect`、`weld` 等），让模型结构更清晰。
- 不参与实际计算，仅作为约束的 “容器”，方便配置和维护。

等式约束用于**强制模型元素满足特定的等式关系**，例如：

- `weld`：将两个刚体 “焊接” 在一起（位置 / 姿态相等）。

- `connect`：约束关节的运动关系（如两个关节的位置差固定）。

这里只详细讲weld；

### **1、weld子节点：**

​		`equality/weld` 是 MuJoCo 中**等式约束的一种**，用于 **“柔性焊接” 两个刚体 **，强制它们保持相对位置和姿态固定（类似物理焊接，但通过约束求解器柔性实现）。

**1. 柔性约束（非刚性）：**

与直接将刚体设为父子关系（刚性焊接）不同，`weld` 是**柔性约束**：

- 约束通过求解器 “软” 执行，允许微小误差（避免仿真发散）。
- 可与其他约束（如关节、碰撞）协同工作。

其有两种方式定义焊接关系：

​			**body or site**

**方式 1：通过 `body1` + 可选参数（默认位姿对齐）：**

- **参数**：`body1`（必选）、`anchor`（可选）、`relpose`（可选）、`body2`（可选）。
- **逻辑**：假设模型默认配置（`mjModel.qpos0`）下约束已满足，焊接后保持该配置的相对位姿。

**方式 2：通过 `site1` + `site2`（任意位姿对齐）:**

- **参数**：`site1`、`site2`（均必选）。
- **逻辑**：对齐两个站点（`site`）的坐标系，无论它们在默认配置中的位置如何。

**模拟刚性连接但需柔性约束：**

​		如机器人的 “虚拟焊接”（需与碰撞、关节协同，不能直接刚性关联）。

**对齐任意位姿的刚体：**

​		通过 `site1` + `site2` 可焊接两个初始位姿无关的刚体，强制对齐它们的站点。

**模型复用：**

​		若模型默认配置已包含正确位姿，用 `body1` 方式可快速焊接。

下面来讲一下该节点下的配置元素：

#### **1.1、name：**

​		定义焊接的名称；



#### **1.2、body1与body2：**

​		`body1` 是 `equality/weld` 约束中**参与焊接的第一个刚体名称**，用于定义焊接关系的 “主动刚体”。

 **核心作用：**

- 标识焊接约束的第一个参与刚体，与 `body2` 或 `site1`/`site2` 配合定义焊接关系。
- 是 `weld` 约束的**必选参数（当不用 `site1`/`site2` 时）**。

`body1` 需与以下方式二选一：

- 搭配 `body2`（可选）+ `anchor`/`relpose`，定义刚体间的焊接。
- 搭配 `site1` + `site2`（均必选），定义站点间的焊接（覆盖刚体默认位姿）。



`body2` 是 `equality/weld` 约束中**参与焊接的第二个刚体名称**，默认值为 “世界刚体（world body）”。

**核心作用：**

- 标识焊接约束的第二个参与刚体，与 `body1` 配合定义刚体间的焊接。
- 若省略，默认焊接到 “世界刚体”（场景的固定坐标系）。



#### **1.3、site1与site2：**

​		`site1` 是 `equality/weld` 约束中**第一个参与刚体的站点名称**，用于定义 “站点级” 的焊接关系，替代传统的 “刚体级” 焊接（`body1`/`body2`）。

**核心作用：**

- 标识第一个刚体上的站点，与 `site2` 配合定义**站点对齐约束**（而非刚体整体焊接）。
- 是 “站点级焊接” 的**必选参数**（需与 `site2` 同时使用）。

`site1` 和 `site2` 定义后，约束求解器会强制：

- 两个站点的**位置重合**（`site1.pos = site2.pos`）。
- 两个站点的**姿态对齐**（`site1.quat = site2.quat`）。

| 特性         | 站点级（`site1`/`site2`）             | 刚体级（`body1`/`body2`）        |
| ------------ | ------------------------------------- | -------------------------------- |
| 默认重叠要求 | 无需重叠（仿真自动对齐）              | 依赖模型默认配置的相对位姿       |
| 运行时动态性 | 支持修改站点位置 / 姿态，约束实时更新 | 依赖 `mjModel.eq_data`，动态性差 |
| 适用场景     | 动态对齐、非默认位姿焊接              | 静态焊接、依赖默认配置的场景     |



#### **1.4、anchor：**

​		`anchor` 是 `equality/weld` 约束中**焊接点在 `body2` 坐标系下的相对坐标**，用于定义焊接约束的 “锚点位置”。









## **十四、body之间的pos关系：**

**1、body之间的pos关系：**

​		每个 `body` 都属于一个**父坐标系**（父 `body` 或世界坐标系 `worldbody`），其 `pos` 是**相对于父坐标系的局部坐标**。

如下代码：

~~~html
<worldbody>
  <!-- 根 body：相对于世界坐标系（pos 是绝对坐标） -->
  <body name="base" pos="0 0 0">  
    <!-- 子 body：相对于 base 的局部坐标 -->
    <body name="arm" pos="0 0 1">  
      <!-- 孙子 body：相对于 arm 的局部坐标 -->
      <body name="hand" pos="0 0.2 0" />  
    </body>
  </body>
</worldbody>
~~~

**坐标计算（运行时）：**

- `base` 的世界坐标：`(0, 0, 0)`（直接继承世界坐标系）。
- `arm` 的世界坐标：`base.pos + arm.pos = (0, 0, 0) + (0, 0, 1) = (0, 0, 1)`。
- `hand` 的世界坐标：`arm.pos + hand.pos = (0, 0, 1) + (0, 0.2, 0) = (0, 0.2, 1)`。



**2、joint与body之间的pos关系：**

​		`joint`的 `pos` 是**关节在父 `body` 中的局部位置**，决定旋转 / 平移的 “支点”。

一般joint的pos给（0 0 0），当前body的（0 0 0）即为该body的父body与该body的连接处的“中心”，即旋转点；



**3、body中geom的关系：**

​		其在所属body的坐标系下；
