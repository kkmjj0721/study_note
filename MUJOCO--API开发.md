# **MUJOCO--API开发（基于python）**

## **目录：**

**1、view&&step**

**2、get  obj**

**3、传感器的数据**























## **一、引言：**

​		在使用python进行API开发时，必须安装python下的mujoco；

安装方法如下（在命令行窗口输入）：

```
pip install mujoco
```

​		在python开发时，必须调用两个库`mujoco`和`mujoco.viewer`

**mujoco 库：**

`mujoco`库是 MuJoCo 物理引擎的 Python 绑定，它主要提供了与 MuJoCo 物理模拟核心功能交互的接口，是实现物理仿真的基础，具体作用如下：

- **模型加载与管理**：允许开发者通过 Python 代码加载 MuJoCo 模型（通常是 MJCF 格式的 XML 文件），并对模型进行各种管理操作，如修改模型参数、添加或删除模型组件等 。比如在机器人仿真场景中，可以加载机器人的模型，设置其初始位置、姿态等。
- **执行物理仿真**：能够控制仿真的运行，包括设置仿真的时间步长、推进仿真的进行等。在仿真过程中，利用 MuJoCo 强大的物理计算能力，精确模拟刚体、软体、关节运动、碰撞等物理现象，广泛应用于强化学习、机器人控制和生物力学研究中 。例如，在强化学习实验里，通过不断推进仿真来让智能体与模拟环境进行交互，学习到最优的控制策略。
- **获取状态信息**：可以获取仿真过程中的各种状态信息，如物体的位置、速度、加速度，关节的角度、扭矩，传感器的读数等。这些信息对于分析仿真结果、调试算法以及训练机器学习模型都至关重要。比如开发人员可以通过获取机器人关节角度数据，来评估控制算法是否使机器人按照预期的轨迹运动 。
- **实时控制仿真环境**：支持在仿真运行过程中实时对环境进行控制，例如向机器人施加力矩、力等，以改变其运动状态。这为实现交互式的仿真和控制提供了可能 。

**mujoco.viewer 库：**

`mujoco.viewer`库是 MuJoCo Python 包中用于可视化的模块，它以`mujoco`库的仿真结果为基础，将抽象的物理模拟数据直观呈现出来，主要作用如下：

- **可视化仿真过程**：提供一个交互式的图形用户界面（GUI），在窗口中实时渲染仿真模型及其运动状态，让用户可以直观地观察到仿真中物体的运动、碰撞等物理现象。比如在教学演示中，教师可以利用该可视化功能，向学生展示复杂的运动学和动力学现象，帮助学生理解抽象的概念 。
- **支持交互操作**：用户可以通过鼠标等进行交互操作，如旋转视角、缩放、平移，以便从不同角度观察仿真场景。此外，还支持在渲染窗口中施加力矩、力等操作，增强用户与仿真环境的互动性 。
- **数据面板展示**：支持在渲染窗口添加数据面板，实时显示仿真数据，如关节角度、速度、力等信息，方便用户监控和分析仿真过程中的关键变量，有助于算法调试，开发人员可以通过观察数据面板中变量的变化，优化算法性能 。
- **支持不同渲染模式**：除了窗口渲染，还支持离屏渲染，离屏渲染的结果可以用于图像处理、视频录制等后续任务，比如批量生成仿真数据视频，用于模型训练等 。









## **二、view&&step:**

​		本章主要讲解渲染以及仿真；

必须调用的两个函数：

~~~python
m = mujoco.MjModel.from_xml_path('A:\mujoco_learning-main (1)\mujoco_learning-main\API-MJC\pointer.xml')
d = mujoco.MjData(m)
~~~

​		如上，一个是将存储在本地文件系统中的 MuJoCo 模型描述文件（通常是 MJCF 格式的 XML 文件），转换为`MjModel`对象。`MjModel`对象是 MuJoCo 在 Python 中用于表示物理模型的类，通过这个对象，开发者可以访问和操作模型的各种属性，进行仿真计算等操作。

​		该函数的返回值是一个`MjModel`类的实例对象，通过这个对象，开发者可以获取和修改模型的各种属性，比如：

- **获取模型基本信息**：可以获取模型中包含的物体数量、关节数量、自由度数量等信息。例如，通过`model.nbody`可以获取模型中刚体的数量。
- **访问模型几何结构**：访问模型中物体的几何形状、尺寸、位置和姿态等信息。比如，通过`model.geom_size`可以获取所有几何形状的尺寸信息。
- **获取动力学参数**：获取模型的质量、惯性张量、摩擦系数等动力学相关参数，这些参数对于物理仿真至关重要。例如，通过`model.body_mass`可以获取每个刚体的质量。



​		另一个用于存储和管理与物理仿真过程相关的数据。它紧密关联着`MjModel`（存储模型的结构和参数信息），在仿真运行时，`MjData`负责记录模型状态、传感器读数等实时变化的数据，下面为你详细介绍：

**数据存储功能：**

- 状态变量：
  - **位置与姿态**：存储模型中各个物体（刚体）的位置和姿态信息。例如，`MjData`对象中的`xpos`属性，是一个数组，记录了每个刚体在世界坐标系下的三维位置；`xquat`属性则记录了每个刚体的四元数姿态，通过这些数据可以精确描述物体在仿真环境中的空间状态。
  - **速度**：包含线速度和角速度数据。`v`属性记录了刚体的线速度，`qv`属性记录了刚体的角速度，这些数据对于理解物体的运动趋势以及动力学分析至关重要。
  - **关节状态**：保存关节的角度、角速度等信息。比如`qpos`记录关节的位置（角度），`qvel`记录关节的速度，在机器人仿真中，这些数据直接反映了机器人各关节的工作状态。
- 力与力矩：
  - 存储作用在物体和关节上的力和力矩信息。`f_ext`属性记录了施加在刚体上的外部力，`tau`属性记录了作用在关节上的力矩，通过对这些力和力矩的分析与控制，可以改变物体和关节的运动状态。
- 传感器数据：
  - 如果模型中定义了传感器（如力传感器、位置传感器等），`MjData`会存储传感器的实时读数。例如，对于力传感器，其测量得到的力值会被记录在相应的属性中，方便开发者获取和分析传感器数据，用于反馈控制、状态监测等应用。

**与仿真过程的关联：**

- **仿真推进**：在每次仿真步长推进时，MuJoCo 会根据`MjModel`中定义的物理模型参数（如质量、摩擦系数等）以及当前`MjData`中的状态信息，计算并更新`MjData`中的各个变量。例如，根据施加在物体上的力和力矩，结合物体的质量和惯性，计算出新的位置、速度等状态，从而实现物理仿真的动态更新。
- **交互控制**：开发者可以通过修改`MjData`中的某些变量来实现对仿真环境的实时控制。比如，在机器人仿真中，通过修改`tau`属性（关节力矩），可以改变机器人关节的运动，进而实现对机器人动作的控制。

**注意事项：**

- **依赖模型对象**：`MjData`对象的创建依赖于`MjModel`对象，在创建`MjData`时，**需要传入正确的`MjModel`实例**，否则会导致错误。
- **数据更新机制**：`MjData`中的数据会随着仿真的推进而自动更新，但如果开发者手动修改了某些数据，需要确保修改的合理性和一致性，避免导致仿真结果出现不符合物理规律的情况。
- **内存管理**：在大规模、长时间的仿真中，`MjData`可能会占用一定的内存空间，需要注意合理管理内存，避免内存泄漏等问题。



使用上面两个参数均会返回一个对象（结构体），里面有什么内容（属性）可在官网（API Reference）中查找



~~~python
with mujoco.viewer.launch_passive(model, data) as viewer:
~~~

用于**启动一个被动模式的可视化窗口**，其核心特点是：

- 查看器**不会主动推进仿真**，而是被动等待外部更新仿真状态
- 可视化窗口会实时渲染`MjModel`（模型）和`MjData`（状态数据）的当前状态
- 支持基本的视角操作（旋转、缩放、平移），但不允许用户通过界面直接干预仿真（如施加力 / 力矩）

这种模式适合需要精确控制仿真节奏的场景，例如：

- 逐步调试仿真逻辑，观察每一步的状态变化
- 配合外部控制算法（如强化学习策略），按自定义频率更新仿真
- 录制仿真过程或生成离线渲染帧

![image-20250830105524582](C:\Users\21716\AppData\Roaming\Typora\typora-user-images\image-20250830105524582.png)

官方解释如上；

- **`model`**（必填）：`MjModel`对象，即通过 XML 加载的物理模型
- **`data`**（必填）：`MjData`对象，存储仿真状态数据
- **`viewer`**：上下文管理器返回的查看器实例，可用于控制窗口行为（如刷新画面）

**工作流程：**

1. **启动窗口**：进入`with`代码块时，自动创建并显示可视化窗口，初始化渲染环境
2. **被动更新**：窗口不会主动运行仿真，需在代码块内手动调用`mujoco.mj_step(model, data)`推进仿真，并通过`viewer.sync()`刷新画面
3. **自动清理**：退出`with`代码块时，自动关闭窗口并释放资源，避免内存泄漏

**`viewer.sync()`：**

- 必须在每次更新`data`后调用，用于将最新的仿真状态同步到可视化窗口
- 内部会处理渲染逻辑，确保画面与`data`中的状态一致
- 如果不调用，窗口会保持初始状态，无法观察到仿真变化



**其仿真接口有四个：**

### **1、mj_step：**

​		其包括前向动力学（计算加速度，qacc），数值积分（更新状态qpos、qvel），处理碰撞和约束，更新传感器数据；

**核心作用：**

`mj_step` 函数的本质是**执行一次完整的物理仿真迭代**，具体包括：

1. 读取当前 `MjData` 中的状态（如物体位置、速度、施加的力）
2. 根据 `MjModel` 定义的物理规则（质量、关节约束、摩擦系数等）
3. 通过动力学计算和数值积分，得到下一时刻的系统状态
4. 自动更新 `MjData` 中的所有状态变量（位置、速度、力等）

简单说，调用一次 `mj_step`，就相当于让仿真世界 “前进一小步”。

~~~python
mujoco.mj_step(model, data, nstep=1)
~~~

**参数说明：**

- **`model`**（必填）：`MjModel` 类型，包含物理模型的静态参数（如刚体数量、关节类型、质量分布等），通过 `from_xml_path` 加载模型文件获得。
- **`data`**（必填）：`MjData` 类型，存储仿真的动态状态（如位置 `qpos`、速度 `qvel`、力 `tau` 等），必须与 `model` 对应。
- **`nstep`**（可选，默认 = 1）：一次调用执行的仿真步数。例如 `nstep=10` 会连续推进 10 步，等价于循环调用 `mj_step` 10 次。

`mj_step` 执行时会按以下步骤完成一次仿真迭代（简化版）：

1. **施加控制信号**：读取 `data.ctrl` 或 `data.tau` 中的控制量（如关节力矩）（控制量是一个数组按照创建驱动器的顺序定义）。
2. **前向动力学**：根据当前状态和控制量，计算各刚体的加速度。
3. **数值积分**：使用配置的积分器（如欧拉法、RK4）更新位置和速度。
4. **碰撞检测**：检测刚体间的碰撞，计算接触力。
5. **约束求解**：处理关节约束、接触约束，确保运动符合物理规则。
6. **更新状态**：将计算结果写入 `data` 中的对应字段（如 `xpos`、`qvel` 等）。

**关键注意事项：**

1. **时间步长**：
   - 仿真步长由 `model.opt.timestep` 定义（单位：秒），通常在 XML 模型中设置（如 `<option timestep="0.01"/>` 表示 10ms 一步）。
   - `mj_step` 每次调用推进的物理时间 = `timestep × nstep`。
2. **状态一致性**：
   - 调用 `mj_step` 前修改 `data` 中的控制量（如 `tau`、`ctrl`）会影响当前步的计算。
   - 调用后 `data` 中的所有状态变量会被覆盖，无需手动更新。
3. **计算成本**：
   - 复杂模型（如多刚体、高自由度）的 `mj_step` 计算耗时更长。
   - 增大 `nstep` 可减少函数调用次数，但会降低实时交互的灵活性。
4. **与可视化配合**：
   - 在被动查看器（`launch_passive`）中，需在 `mj_step` 后调用 `viewer.sync()` 刷新画面。
   - 主动查看器（`launch`）会自动调用 `mj_step`，无需手动处理。



### **2、mj_step1、mj_step2：**

​		`mujoco.mj_step1`和`mujoco.mj_step2`是`mujoco.mj_step`函数的**拆分版本**，用于更精细地控制仿真步骤的执行流程。这种拆分允许开发者在仿真计算的特定阶段插入自定义逻辑（如修改控制信号、施加外力等）；

**mj_step1：**

​		计算当前状态下的广义加速度（qacc），处理碰撞检测，但不应用约束；

**mj_step2：**

​		应用用户设置的ctrl和xfrc_applied，处理约束（接触力，关节限位等），数值积分更新状态（qpos，qvel），更新仿真时间

d->time；

~~~python
mujoco.mj_step1(m, d)
d.ctrl[1] = math.sin(cnt)
mujoco.mj_step2(m, d)
~~~

`mj_step`函数本质上是对物理仿真全流程的封装，而`mj_step1`和`mj_step2`将其拆分为两个阶段：

- **`mj_step1(m, d)`**：执行仿真的**前半段计算**（主要是准备工作和部分动力学计算）
- **`mj_step2(m, d)`**：执行仿真的**后半段计算**（完成动力学求解和状态更新）

两者结合使用等价于调用一次`mj_step(m, d)`，但中间可以插入自定义代码。

**拆分流程与时机：**

完整的`mj_step`流程被拆分为：

1. **调用`mj_step1(m, d)`**：
   - 处理模型的初始状态（如关节限制、接触检测初始化）
   - 计算部分动力学参数（如惯性矩阵、重力项）
   - 为后续的控制输入和力计算做准备
2. **插入自定义逻辑**（核心价值）：
   - 可以修改控制信号（`d.ctrl`）、关节力矩（`d.tau`）
   - 施加外部力（`d.f_ext`）或修改传感器数据
   - 读取中间状态用于决策（如强化学习的策略输出）
3. **调用`mj_step2(m, d)`**：
   - 根据`step1`的结果和中间插入的控制信号，完成动力学计算
   - 求解加速度（`qacc`）、更新速度（`qvel`）和位置（`qpos`）
   - 处理碰撞响应和约束求解，最终更新`d`中的所有状态

| 方式                     | 适用场景                          | 灵活性                   |
| ------------------------ | --------------------------------- | ------------------------ |
| `mj_step(m, d)`          | 无需中间干预的常规仿真            | 低（无法插入自定义逻辑） |
| `step1 + 自定义 + step2` | 需要在仿真中途修改控制 / 力的场景 | 高（支持精细控制）       |

**关键使用场景：**

1. **实时控制插入**：
   - 在机器人控制中，可在`step1`后根据当前状态（如传感器数据）计算控制量，再由`step2`执行
   - 确保控制信号的时效性（控制量与当前状态严格匹配）
2. **强化学习集成**：
   - 在`step1`后读取当前观测（`data`中的状态），通过智能体生成动作（修改`ctrl`或`tau`）
   - 再由`step2`执行动作，保证决策与执行的同步性
3. **复杂力 / 力矩调整**：
   - 可在中间阶段动态修改外部力（`d.f_ext`），模拟突发外力（如碰撞、风干扰）



### **3、mj_forward：**

​		`mujoco.mj_forward`是一个关键函数，主要用于**计算模型的正向动力学（forward dynamics）** 并更新状态数据，但其核心作用并非推进仿真时间，而是根据当前状态计算并更新模型的衍生信息。

**根据当前状态（位置、速度，力等）计算系统的中间动力学量（广义加速度qacc）**，但不执行时间积分（即不更新位置和速度）。具体来说，它会：

1. 根据当前`qpos`（广义位置）和`qvel`（广义速度）计算衍生状态（如刚体的世界坐标`xpos`、姿态`xquat`）
2. 求解正向动力学，计算广义加速度`qacc`（基于当前力、力矩和约束）
3. 更新传感器数据、接触信息等辅助状态

​		简单讲，`mj_forward`是 “状态计算器”，负责将基础状态（`qpos`、`qvel`）转换为更丰富的衍生信息（如加速度、世界坐标、传感器读数），为后续的仿真步（`mj_step`）或分析提供数据支持。

~~~python
d.ctrl[0] = math.sin(cnt)
d.qpos[0] = math.sin(cnt)
mujoco.mj_forward(m, d)
~~~

- **`model`**：`MjModel`对象，存储模型的静态参数（如结构、质量、约束等）
- **`data`**：`MjData`对象，存储当前状态（`qpos`、`qvel`等），函数会更新其中的衍生状态（`xpos`、`qacc`、传感器数据等）

`mj_forward`的执行步骤可简化为：

1. **正向运动学（Forward Kinematics）**：
   - 根据`qpos`计算所有刚体的世界坐标（`xpos`）、姿态（`xquat`）
   - 计算关节位置、速度的衍生信息（如`jnt_pos`、`jnt_vel`）
2. **正向动力学（Forward Dynamics）**：
   - 结合`qpos`、`qvel`、施加的力（`tau`、`f_ext`）和模型参数（质量、惯性等）
   - 求解动力学方程，计算广义加速度`qacc`（与`mj_step`中计算`qacc`的逻辑一致）
3. **辅助状态更新**：
   - 计算传感器读数（如力传感器、位置传感器的输出）
   - 检测碰撞并更新接触信息（`data.contact`）
   - 计算能量、动量等辅助物理量

**注意事项：**

- **依赖初始状态**：`mj_forward`的计算结果完全依赖当前`data`中的`qpos`和`qvel`，若这些值不合理（如违反关节约束），可能导致计算错误（如`qacc`出现异常值）。
- **与`mj_step`的配合**：`mj_step`内部会自动调用`mj_forward`，因此在常规仿真中无需手动调用；仅当手动修改状态或需要中间数据时，才需显式调用。
- **计算成本**：`mj_forward`是`mj_step`的核心子步骤，计算成本与模型复杂度正相关（复杂模型可能耗时较长）。

| 操作                  | 时间是否推进 | `qpos`/`qvel`是否变化 | 衍生信息（`xpos`/`qacc`等）是否更新          |
| --------------------- | ------------ | --------------------- | -------------------------------------------- |
| `mj_forward`          | 否           | 否（除非手动修改）    | 是（基于当前`qpos`/`qvel`重新计算）          |
| `mj_step`（推进仿真） | 是           | 是（通过积分更新）    | 是（先调用`mj_forward`计算，再更新核心状态） |



### **4、mj_inverse：**

​		`mujoco.mj_inverse`是用于计算**逆动力学（inverse dynamics）** 的核心函数。与正向动力学（由力计算运动）相反，逆动力学的核心作用是：**根据系统的位置、速度和加速度，计算产生该运动所需的力或力矩**。

`mj_inverse`的核心功能是求解逆动力学方程，具体来说：

- 输入：系统的当前位置（`qpos`）、速度（`qvel`）和目标加速度（`qacc`）
- 输出：为了实现该加速度，需要施加在关节上的力或力矩（存储在`data.tau`中）

简单讲，**正向动力学是 “已知力，求运动”（如`mj_forward`计算`qacc`），而逆动力学是 “已知运动，求力”**（`mj_inverse`计算`tau`）。

1. **feedforward 控制 ：**
   - 在高精度控制中，可将`mj_inverse`计算的力矩作为前馈项，补偿系统的惯性力、重力等，配合反馈控制提高精度。
2. **运动规划验证**：
   - 规划出一条运动轨迹后，用`mj_inverse`检查所需力矩是否在执行器（如电机）的能力范围内，避免规划出无法实现的运动。

**与其他函数的关联：**

- **与`mj_forward`的对比**：
  - `mj_forward`：输入`qpos`、`qvel`、`tau` → 输出`qacc`（正向动力学）
  - `mj_inverse`：输入`qpos`、`qvel`、`qacc` → 输出`tau`（逆动力学）
    两者是互逆过程，共同构成了动力学计算的核心。
- **与`mj_step`的配合**：
  - `mj_inverse`计算的`tau`可直接用于`mj_step`，驱动仿真按目标加速度运动：

~~~python
# 计算目标力矩
mujoco.mj_inverse(model, data)
# 用计算出的力矩推进仿真
mujoco.mj_step(model, data)
~~~









## **三、get obj：**

​		本节主要为获取model对象的一些数据如body_id、body_pos、body_name等；不做过多介绍，自行去官网查找；

**获取名字：**

数量 ![image-20250830142254720](C:\Users\21716\AppData\Roaming\Typora\typora-user-images\image-20250830142254720.png)

 **先看mjModel结构体开头部分，这里的命名方式都是nXXX，这代表各个元素的数量** !![image-20250830142303352](C:\Users\21716\AppData\Roaming\Typora\typora-user-images\image-20250830142303352.png)

**获取id：**

`MJAPI int mj_name2id(const mjModel* m, int type, const char* name);` **通过name获取实体的id
m :mjModel type: mjmodel.h文件中的mjtObj中定义，这个是要获取id的实体类型一下是部分type类型枚举，在mjtObj中找到
name: name **
![image-20250830142327108](C:\Users\21716\AppData\Roaming\Typora\typora-user-images\image-20250830142327108.png)

**获取位置：**

![image-20250830142400475](C:\Users\21716\AppData\Roaming\Typora\typora-user-images\image-20250830142400475.png) **可以通过 xpos和xxx_xpos获取各个对象的位置**

**获取姿态：**

**通过xquat可以获取body的姿态**

我们可以和C++接口一样通过m.names中寻找各个实体的名字nXXX得到实体数量，name_xxxadr来寻找实体名字在names中的索引。 在names中名字字符串之间通过”\x00”分割，name_xxxadr定位到的是该实体的第一个字符的位置，可以使用python的数组截取功能实现读取字符串，在寻找末尾的0来截取实体的实际名字。

```python
name= m.names[m.name_bodyadr[1]:]
for i in range(len(name)):
if name[i] == 0:
name = name[:i]
break
print(name)
```

我们在获取某一实体的name时，是一个数组，我们需要根据mjcf中定义的顺序进行查找；









## **四、传感器的数据：**



























## 、**mujoco中其他函数讲解：**

### **1、viewer.lock( )：**

​		核心功能是**获取查看器的全局锁**，确保在 `with` 代码块内对仿真状态（`model` 或 `data`）的操作是**原子性**的，不会与查看器的渲染线程产生冲突。

- 查看器（`viewer`）内部运行着独立的渲染线程，负责实时刷新窗口画面。
- 若主线程（或其他线程）同时修改 `data` 中的状态（如位置、速度），可能与渲染线程读取数据的操作冲突，导致画面闪烁、数据错乱甚至程序崩溃。
- `with viewer.lock():` 通过加锁机制，保证同一时间只有一个线程能访问 `model` 或 `data`，从而避免冲突。

若在 `sync()` 前修改 `data`，同样建议使用 `lock()` 确保安全：

~~~python
with mujoco.viewer.launch_passive(model, data) as viewer:
    while True:
        with viewer.lock():
            # 安全修改状态并推进仿真
            data.tau[0] = 1.0
            mujoco.mj_step(model, data)
        
        # 刷新画面（内部会检查锁状态）
        viewer.sync()
        time.sleep(0.01)
~~~

**注意事项：**

- **最小化锁持有时间**：`with viewer.lock():` 代码块应尽可能精简，仅包含必要的状态修改操作，避免长时间持有锁导致渲染卡顿（如将耗时的计算放在锁外部）。
- **无需锁的场景**：若仅读取 `data` 中的状态（不修改），且查看器处于被动模式，通常无需加锁（但主动模式下仍建议加锁，避免潜在冲突）。
- **兼容性**：旧版本的 `mujoco.viewer` 可能没有 `lock()` 方法，需确保使用较新的 MuJoCo 版本（如 2.3.0+）。
